{"version":3,"file":"index.0e6ed1ec.js","sources":["../../../../../../node_modules/svelte-dnd-action/src/helpers/util.js","../../../../../../node_modules/svelte-dnd-action/src/helpers/observer.js","../../../../../../node_modules/svelte-dnd-action/src/helpers/scroller.js","../../../../../../node_modules/svelte-dnd-action/src/helpers/multiScroller.js","../../../../../../node_modules/svelte-dnd-action/src/helpers/svelteNodeClone.js","../../../../../../node_modules/svelte-dnd-action/src/helpers/styler.js","../../../../../../node_modules/svelte-dnd-action/src/pointerAction.js","../../../../../../node_modules/svelte-dnd-action/src/helpers/aria.js","../../../../../../node_modules/svelte-dnd-action/src/keyboardAction.js","../../../../../../node_modules/svelte-dnd-action/src/action.js","../../../../../../node_modules/svelte/animate/index.mjs"],"sourcesContent":["/**\n * @param {Object} object\n * @return {string}\n */\nexport function toString(object) {\n    return JSON.stringify(object, null, 2);\n}\n\n/**\n * Finds the depth of the given node in the DOM tree\n * @param {HTMLElement} node\n * @return {number} - the depth of the node\n */\nexport function getDepth(node) {\n    if (!node) {\n        throw new Error(\"cannot get depth of a falsy node\");\n    }\n    return _getDepth(node, 0);\n}\nfunction _getDepth(node, countSoFar = 0) {\n    if (!node.parentElement) {\n        return countSoFar - 1;\n    }\n    return _getDepth(node.parentElement, countSoFar + 1);\n}\n\n/**\n * A simple util to shallow compare objects quickly, it doesn't validate the arguments so pass objects in\n * @param {Object} objA\n * @param {Object} objB\n * @return {boolean} - true if objA and objB are shallow equal\n */\nexport function areObjectsShallowEqual(objA, objB) {\n    if (Object.keys(objA).length !== Object.keys(objB).length) {\n        return false;\n    }\n    for (const keyA in objA) {\n        if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Shallow compares two arrays\n * @param arrA\n * @param arrB\n * @return {boolean} - whether the arrays are shallow equal\n */\nexport function areArraysShallowEqualSameOrder(arrA, arrB) {\n    if (arrA.length !== arrB.length) {\n        return false;\n    }\n    for (let i = 0; i < arrA.length; i++) {\n        if (arrA[i] !== arrB[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","import {findWouldBeIndex, resetIndexesCache} from \"./listUtil\";\nimport {findCenterOfElement, isElementOffDocument} from \"./intersection\";\nimport {\n    dispatchDraggedElementEnteredContainer,\n    dispatchDraggedElementLeftContainerForAnother,\n    dispatchDraggedElementLeftContainerForNone,\n    dispatchDraggedLeftDocument,\n    dispatchDraggedElementIsOverIndex\n} from \"./dispatcher\";\nimport {getDepth} from \"./util\";\nimport {printDebug} from \"../constants\";\n\nconst INTERVAL_MS = 200;\nconst TOLERANCE_PX = 10;\nlet next;\n\n/**\n * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)\n * @param {Set<HTMLElement>} dropZones\n * @param {HTMLElement} draggedEl\n * @param {number} [intervalMs = INTERVAL_MS]\n * @param {MultiScroller} multiScroller\n */\nexport function observe(draggedEl, dropZones, intervalMs = INTERVAL_MS, multiScroller) {\n    // initialization\n    let lastDropZoneFound;\n    let lastIndexFound;\n    let lastIsDraggedInADropZone = false;\n    let lastCentrePositionOfDragged;\n    // We are sorting to make sure that in case of nested zones of the same type the one \"on top\" is considered first\n    const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n\n    /**\n     * The main function in this module. Tracks where everything is/ should be a take the actions\n     */\n    function andNow() {\n        const currentCenterOfDragged = findCenterOfElement(draggedEl);\n        const scrolled = multiScroller.multiScrollIfNeeded();\n        // we only want to make a new decision after the element was moved a bit to prevent flickering\n        if (\n            !scrolled &&\n            lastCentrePositionOfDragged &&\n            Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX &&\n            Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX\n        ) {\n            next = window.setTimeout(andNow, intervalMs);\n            return;\n        }\n        if (isElementOffDocument(draggedEl)) {\n            printDebug(() => \"off document\");\n            dispatchDraggedLeftDocument(draggedEl);\n            return;\n        }\n\n        lastCentrePositionOfDragged = currentCenterOfDragged;\n        // this is a simple algorithm, potential improvement: first look at lastDropZoneFound\n        let isDraggedInADropZone = false;\n        for (const dz of dropZonesFromDeepToShallow) {\n            if (scrolled) resetIndexesCache();\n            const indexObj = findWouldBeIndex(draggedEl, dz);\n            if (indexObj === null) {\n                // it is not inside\n                continue;\n            }\n            const {index} = indexObj;\n            isDraggedInADropZone = true;\n            // the element is over a container\n            if (dz !== lastDropZoneFound) {\n                lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl, dz);\n                dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl);\n                lastDropZoneFound = dz;\n            } else if (index !== lastIndexFound) {\n                dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl);\n                lastIndexFound = index;\n            }\n            // we handle looping with the 'continue' statement above\n            break;\n        }\n        // the first time the dragged element is not in any dropzone we need to notify the last dropzone it was in\n        if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {\n            dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl);\n            lastDropZoneFound = undefined;\n            lastIndexFound = undefined;\n            lastIsDraggedInADropZone = false;\n        } else {\n            lastIsDraggedInADropZone = true;\n        }\n        next = window.setTimeout(andNow, intervalMs);\n    }\n    andNow();\n}\n\n// assumption - we can only observe one dragged element at a time, this could be changed in the future\nexport function unobserve() {\n    printDebug(() => \"unobserving\");\n    clearTimeout(next);\n    resetIndexesCache();\n}\n","import {isPointInsideRect} from \"./intersection\";\nconst SCROLL_ZONE_PX = 30;\n\n/**\n * Will make a scroller that can scroll any element given to it in any direction\n * @returns {{scrollIfNeeded: function(Point, HTMLElement): boolean, resetScrolling: function(void):void}}\n */\nexport function makeScroller() {\n    let scrollingInfo;\n    function resetScrolling() {\n        scrollingInfo = {directionObj: undefined, stepPx: 0};\n    }\n    resetScrolling();\n    // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x\n    function scrollContainer(containerEl) {\n        const {directionObj, stepPx} = scrollingInfo;\n        if (directionObj) {\n            containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);\n            window.requestAnimationFrame(() => scrollContainer(containerEl));\n        }\n    }\n    function calcScrollStepPx(distancePx) {\n        return SCROLL_ZONE_PX - distancePx;\n    }\n\n    /**\n     * @param {Point} pointer - the pointer will be used to decide in which direction to scroll\n     * @param {HTMLElement} elementToScroll - the scroll container\n     * If the pointer is next to the sides of the element to scroll, will trigger scrolling\n     * Can be called repeatedly with updated pointer and elementToScroll values without issues\n     * @return {boolean} - true if scrolling was needed\n     */\n    function scrollIfNeeded(pointer, elementToScroll) {\n        if (!elementToScroll) {\n            return false;\n        }\n        const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);\n        if (distances === null) {\n            resetScrolling();\n            return false;\n        }\n        const isAlreadyScrolling = !!scrollingInfo.directionObj;\n        let [scrollingVertically, scrollingHorizontally] = [false, false];\n        // vertical\n        if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {\n            if (distances.bottom < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: 1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);\n            } else if (distances.top < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: -1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.top);\n            }\n            if (!isAlreadyScrolling && scrollingVertically) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        // horizontal\n        if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {\n            if (distances.right < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: 1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.right);\n            } else if (distances.left < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: -1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.left);\n            }\n            if (!isAlreadyScrolling && scrollingHorizontally) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        resetScrolling();\n        return false;\n    }\n\n    return {\n        scrollIfNeeded,\n        resetScrolling\n    };\n}\n\n/**\n * If the point is inside the element returns its distances from the sides, otherwise returns null\n * @param {Point} point\n * @param {HTMLElement} el\n * @return {null|{top: number, left: number, bottom: number, right: number}}\n */\nfunction calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {\n    // Even if the scrolling element is small it acts as a scroller for the viewport\n    const rect =\n        el === document.scrollingElement\n            ? {\n                  top: 0,\n                  bottom: window.innerHeight,\n                  left: 0,\n                  right: window.innerWidth\n              }\n            : el.getBoundingClientRect();\n    if (!isPointInsideRect(point, rect)) {\n        return null;\n    }\n    return {\n        top: point.y - rect.top,\n        bottom: rect.bottom - point.y,\n        left: point.x - rect.left,\n        right: rect.right - point.x\n    };\n}\n","import {makeScroller} from \"./scroller\";\nimport {printDebug} from \"../constants\";\nimport {getDepth} from \"./util\";\nimport {isPointInsideRect} from \"./intersection\";\n\n/**\n @typedef {Object} MultiScroller\n @property {function():boolean} multiScrollIfNeeded - call this on every \"tick\" to scroll containers if needed, returns true if anything was scrolled\n/**\n * Creates a scroller than can scroll any of the provided containers or any of their scrollable parents (including the document's scrolling element)\n * @param {HTMLElement[]} baseElementsForScrolling\n * @param {function():Point} getPointerPosition\n * @return {MultiScroller}\n */\nexport function createMultiScroller(baseElementsForScrolling = [], getPointerPosition) {\n    printDebug(() => \"creating multi-scroller\");\n    const scrollingContainersSet = findRelevantScrollContainers(baseElementsForScrolling);\n    const scrollingContainersDeepToShallow = Array.from(scrollingContainersSet).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n    const {scrollIfNeeded} = makeScroller();\n\n    /**\n     * @return {boolean} - was any container scrolled\n     */\n    function tick() {\n        const mousePosition = getPointerPosition();\n        if (!mousePosition || !scrollingContainersDeepToShallow) {\n            return false;\n        }\n        const scrollContainersUnderCursor = scrollingContainersDeepToShallow.filter(\n            el => isPointInsideRect(mousePosition, el.getBoundingClientRect()) || el === document.scrollingElement\n        );\n        for (let i = 0; i < scrollContainersUnderCursor.length; i++) {\n            const scrolled = scrollIfNeeded(mousePosition, scrollContainersUnderCursor[i]);\n            if (scrolled) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return {\n        multiScrollIfNeeded: scrollingContainersSet.size > 0 ? tick : () => false\n    };\n}\n\n// internal utils\nfunction findScrollableParents(element) {\n    if (!element) {\n        return [];\n    }\n    const scrollableContainers = [];\n    let parent = element;\n    while (parent) {\n        const {overflow} = window.getComputedStyle(parent);\n        if (overflow.split(\" \").some(o => o.includes(\"auto\") || o.includes(\"scroll\"))) {\n            scrollableContainers.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    return scrollableContainers;\n}\nfunction findRelevantScrollContainers(dropZones) {\n    const scrollingContainers = new Set();\n    for (let dz of dropZones) {\n        findScrollableParents(dz).forEach(container => scrollingContainers.add(container));\n    }\n    // The scrolling element might have overflow visible and still be scrollable\n    if (\n        document.scrollingElement.scrollHeight > document.scrollingElement.clientHeight ||\n        document.scrollingElement.scrollWidth > document.scrollingElement.clientHeight\n    ) {\n        scrollingContainers.add(document.scrollingElement);\n    }\n    return scrollingContainers;\n}\n","/**\n * Fixes svelte issue when cloning node containing (or being) <select> which will loose it's value.\n * Since svelte manages select value internally.\n * @see https://github.com/sveltejs/svelte/issues/6717\n * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306\n *\n * @param {HTMLElement} el\n * @returns\n */\nexport function svelteNodeClone(el) {\n    const cloned = el.cloneNode(true);\n\n    const values = [];\n    const elIsSelect = el.tagName === \"SELECT\";\n    const selects = elIsSelect ? [el] : [...el.querySelectorAll(\"select\")];\n    for (const select of selects) {\n        values.push(select.value);\n    }\n\n    if (selects.length > 0) {\n        const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll(\"select\")];\n        for (let i = 0; i < clonedSelects.length; i++) {\n            const select = clonedSelects[i];\n            const value = values[i];\n            const optionEl = select.querySelector(`option[value=\"${value}\"`);\n            if (optionEl) {\n                optionEl.setAttribute(\"selected\", true);\n            }\n        }\n    }\n\n    const elIsCanvas = el.tagName === \"CANVAS\";\n    const canvases = elIsCanvas ? [el] : [...el.querySelectorAll(\"canvas\")];\n    if (canvases.length > 0) {\n        const clonedCanvases = elIsCanvas ? [cloned] : [...cloned.querySelectorAll(\"canvas\")];\n        for (let i = 0; i < clonedCanvases.length; i++) {\n            const canvas = canvases[i];\n            const clonedCanvas = clonedCanvases[i];\n            clonedCanvas.width = canvas.width;\n            clonedCanvas.height = canvas.height;\n            clonedCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n        }\n    }\n\n    return cloned;\n}\n","import {SHADOW_ELEMENT_ATTRIBUTE_NAME, DRAGGED_ELEMENT_ID} from \"../constants\";\nimport {findCenter} from \"./intersection\";\nimport {svelteNodeClone} from \"./svelteNodeClone\";\nimport {getFeatureFlag, FEATURE_FLAG_NAMES} from \"../featureFlags\";\n\nconst TRANSITION_DURATION_SECONDS = 0.2;\n\n/**\n * private helper function - creates a transition string for a property\n * @param {string} property\n * @return {string} - the transition string\n */\nfunction trs(property) {\n    return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;\n}\n/**\n * clones the given element and applies proper styles and transitions to the dragged element\n * @param {HTMLElement} originalElement\n * @param {Point} [positionCenterOnXY]\n * @return {Node} - the cloned, styled element\n */\nexport function createDraggedElementFrom(originalElement, positionCenterOnXY) {\n    const rect = originalElement.getBoundingClientRect();\n    const draggedEl = svelteNodeClone(originalElement);\n    copyStylesFromTo(originalElement, draggedEl);\n    draggedEl.id = DRAGGED_ELEMENT_ID;\n    draggedEl.style.position = \"fixed\";\n    let elTopPx = rect.top;\n    let elLeftPx = rect.left;\n    draggedEl.style.top = `${elTopPx}px`;\n    draggedEl.style.left = `${elLeftPx}px`;\n    if (positionCenterOnXY) {\n        const center = findCenter(rect);\n        elTopPx -= center.y - positionCenterOnXY.y;\n        elLeftPx -= center.x - positionCenterOnXY.x;\n        window.setTimeout(() => {\n            draggedEl.style.top = `${elTopPx}px`;\n            draggedEl.style.left = `${elLeftPx}px`;\n        }, 0);\n    }\n    draggedEl.style.margin = \"0\";\n    // we can't have relative or automatic height and width or it will break the illusion\n    draggedEl.style.boxSizing = \"border-box\";\n    draggedEl.style.height = `${rect.height}px`;\n    draggedEl.style.width = `${rect.width}px`;\n    draggedEl.style.transition = `${trs(\"top\")}, ${trs(\"left\")}, ${trs(\"background-color\")}, ${trs(\"opacity\")}, ${trs(\"color\")} `;\n    // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time\n    window.setTimeout(() => (draggedEl.style.transition += `, ${trs(\"width\")}, ${trs(\"height\")}`), 0);\n    draggedEl.style.zIndex = \"9999\";\n    draggedEl.style.cursor = \"grabbing\";\n\n    return draggedEl;\n}\n\n/**\n * styles the dragged element to a 'dropped' state\n * @param {HTMLElement} draggedEl\n */\nexport function moveDraggedElementToWasDroppedState(draggedEl) {\n    draggedEl.style.cursor = \"grab\";\n}\n\n/**\n * Morphs the dragged element style, maintains the mouse pointer within the element\n * @param {HTMLElement} draggedEl\n * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element\n * @param {number} currentMouseX\n * @param {number} currentMouseY\n */\nexport function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY) {\n    copyStylesFromTo(copyFromEl, draggedEl);\n    const newRect = copyFromEl.getBoundingClientRect();\n    const draggedElRect = draggedEl.getBoundingClientRect();\n    const widthChange = newRect.width - draggedElRect.width;\n    const heightChange = newRect.height - draggedElRect.height;\n    if (widthChange || heightChange) {\n        const relativeDistanceOfMousePointerFromDraggedSides = {\n            left: (currentMouseX - draggedElRect.left) / draggedElRect.width,\n            top: (currentMouseY - draggedElRect.top) / draggedElRect.height\n        };\n        if (!getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT)) {\n            draggedEl.style.height = `${newRect.height}px`;\n            draggedEl.style.width = `${newRect.width}px`;\n        }\n        draggedEl.style.left = `${parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;\n        draggedEl.style.top = `${parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;\n    }\n}\n\n/**\n * @param {HTMLElement} copyFromEl\n * @param {HTMLElement} copyToEl\n */\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n    const computedStyle = window.getComputedStyle(copyFromEl);\n    Array.from(computedStyle)\n        .filter(\n            s =>\n                s.startsWith(\"background\") ||\n                s.startsWith(\"padding\") ||\n                s.startsWith(\"font\") ||\n                s.startsWith(\"text\") ||\n                s.startsWith(\"align\") ||\n                s.startsWith(\"justify\") ||\n                s.startsWith(\"display\") ||\n                s.startsWith(\"flex\") ||\n                s.startsWith(\"border\") ||\n                s === \"opacity\" ||\n                s === \"color\" ||\n                s === \"list-style-type\" ||\n                // copying with and height to make up for rect update timing issues in some browsers\n                (getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT) && (s === \"width\" || s === \"height\"))\n        )\n        .forEach(s => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));\n}\n\n/**\n * makes the element compatible with being draggable\n * @param {HTMLElement} draggableEl\n * @param {boolean} dragDisabled\n */\nexport function styleDraggable(draggableEl, dragDisabled) {\n    draggableEl.draggable = false;\n    draggableEl.ondragstart = () => false;\n    if (!dragDisabled) {\n        draggableEl.style.userSelect = \"none\";\n        draggableEl.style.WebkitUserSelect = \"none\";\n        draggableEl.style.cursor = \"grab\";\n    } else {\n        draggableEl.style.userSelect = \"\";\n        draggableEl.style.WebkitUserSelect = \"\";\n        draggableEl.style.cursor = \"\";\n    }\n}\n\n/**\n * Hides the provided element so that it can stay in the dom without interrupting\n * @param {HTMLElement} dragTarget\n */\nexport function hideElement(dragTarget) {\n    dragTarget.style.display = \"none\";\n    dragTarget.style.position = \"fixed\";\n    dragTarget.style.zIndex = \"-5\";\n}\n\n/**\n * styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function decorateShadowEl(shadowEl) {\n    shadowEl.style.visibility = \"hidden\";\n    shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n}\n\n/**\n * undo the styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function unDecorateShadowElement(shadowEl) {\n    shadowEl.style.visibility = \"\";\n    shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n\n/**\n * will mark the given dropzones as visually active\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleActiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = styles[style];\n        });\n        getClasses(dz).forEach(c => dz.classList.add(c));\n    });\n}\n\n/**\n * will remove the 'active' styling from given dropzones\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleInactiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = \"\";\n        });\n        getClasses(dz).forEach(c => dz.classList.contains(c) && dz.classList.remove(c));\n    });\n}\n\n/**\n * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values\n * @param {HTMLElement} el\n * @return {function(): void} - run this function to undo the operation and restore the original values\n */\nexport function preventShrinking(el) {\n    const originalMinHeight = el.style.minHeight;\n    el.style.minHeight = window.getComputedStyle(el).getPropertyValue(\"height\");\n    const originalMinWidth = el.style.minWidth;\n    el.style.minWidth = window.getComputedStyle(el).getPropertyValue(\"width\");\n    return function undo() {\n        el.style.minHeight = originalMinHeight;\n        el.style.minWidth = originalMinWidth;\n    };\n}\n","import {\n    decrementActiveDropZoneCount,\n    incrementActiveDropZoneCount,\n    ITEM_ID_KEY,\n    printDebug,\n    SHADOW_ITEM_MARKER_PROPERTY_NAME,\n    SHADOW_PLACEHOLDER_ITEM_ID,\n    SOURCES,\n    TRIGGERS\n} from \"./constants\";\nimport {observe, unobserve} from \"./helpers/observer\";\nimport {createMultiScroller} from \"./helpers/multiScroller\";\nimport {\n    createDraggedElementFrom,\n    decorateShadowEl,\n    hideElement,\n    morphDraggedElementToBeLike,\n    moveDraggedElementToWasDroppedState,\n    preventShrinking,\n    styleActiveDropZones,\n    styleDraggable,\n    styleInactiveDropZones,\n    unDecorateShadowElement\n} from \"./helpers/styler\";\nimport {\n    dispatchConsiderEvent,\n    dispatchFinalizeEvent,\n    DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_LEFT_DOCUMENT_EVENT_NAME,\n    DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_TYPES,\n    DRAGGED_OVER_INDEX_EVENT_NAME\n} from \"./helpers/dispatcher\";\nimport {areArraysShallowEqualSameOrder, areObjectsShallowEqual, toString} from \"./helpers/util\";\nimport {getBoundingRectNoTransforms} from \"./helpers/intersection\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst MIN_OBSERVATION_INTERVAL_MS = 100;\nconst DISABLED_OBSERVATION_INTERVAL_MS = 20;\nconst MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\nconst ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE = \"data-is-dnd-original-dragged-item\";\n\nlet originalDragTarget;\nlet draggedEl;\nlet draggedElData;\nlet draggedElType;\nlet originDropZone;\nlet originIndex;\nlet shadowElData;\nlet shadowElDropZone;\nlet dragStartMousePosition;\nlet currentMousePosition;\nlet isWorkingOnPreviousDrag = false;\nlet finalizingPreviousDrag = false;\nlet unlockOriginDzMinDimensions;\nlet isDraggedOutsideOfAnyDz = false;\nlet scheduledForRemovalAfterDrop = [];\n\n// a map from type to a set of drop-zones\nconst typeToDropZones = new Map();\n// important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners\nconst dzToConfig = new Map();\n// this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)\nconst elToMouseDownListener = new WeakMap();\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n}\n\n/* functions to manage observing the dragged element and trigger custom drag-events */\nfunction watchDraggedElement() {\n    printDebug(() => \"watching dragged element\");\n    const dropZones = typeToDropZones.get(draggedElType);\n\n    for (const dz of dropZones) {\n        dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n\n    // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth\n    const setIntervalMs = Math.max(...Array.from(dropZones.keys()).map(dz => dzToConfig.get(dz).dropAnimationDurationMs));\n    const observationIntervalMs = setIntervalMs === 0 ? DISABLED_OBSERVATION_INTERVAL_MS : Math.max(setIntervalMs, MIN_OBSERVATION_INTERVAL_MS); // if setIntervalMs is 0 it goes to 20, otherwise it is max between it and min observation.\n    const multiScroller = createMultiScroller(dropZones, () => currentMousePosition);\n    observe(draggedEl, dropZones, observationIntervalMs * 1.07, multiScroller);\n}\nfunction unWatchDraggedElement() {\n    printDebug(() => \"unwatching dragged element\");\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    unobserve();\n}\n\nfunction findShadowElementIdx(items) {\n    return items.findIndex(item => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n}\nfunction createShadowElData(draggedElData) {\n    return {...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID};\n}\n\n/* custom drag-events handlers */\nfunction handleDraggedEntered(e) {\n    printDebug(() => [\"dragged entered\", e.currentTarget, e.detail]);\n    let {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"ignoring dragged entered because drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    // this deals with another race condition. in rare occasions (super rapid operations) the list hasn't updated yet\n    items = items.filter(item => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);\n    printDebug(() => `dragged entered items ${toString(items)}`);\n\n    if (originDropZone !== e.currentTarget) {\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        const newOriginZoneItems = originZoneItems.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n        dispatchConsiderEvent(originDropZone, newOriginZoneItems, {\n            trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    const {index, isProximityBased} = e.detail.indexObj;\n    const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;\n    shadowElDropZone = e.currentTarget;\n    items.splice(shadowElIdx, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\nfunction handleDraggedLeft(e) {\n    // dealing with a rare race condition on extremely rapid clicking and dropping\n    if (!isWorkingOnPreviousDrag) return;\n    printDebug(() => [\"dragged left\", e.currentTarget, e.detail]);\n    const {items: originalItems, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const items = [...originalItems];\n    const shadowElIdx = findShadowElementIdx(items);\n    if (shadowElIdx !== -1) {\n        items.splice(shadowElIdx, 1);\n    }\n    const origShadowDz = shadowElDropZone;\n    shadowElDropZone = undefined;\n    const {type, theOtherDz} = e.detail;\n    if (\n        type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY ||\n        (type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled)\n    ) {\n        printDebug(() => \"dragged left all, putting shadow element back in the origin dz\");\n        isDraggedOutsideOfAnyDz = true;\n        shadowElDropZone = originDropZone;\n        // if the last zone it left is the origin dz, we will put it back into items (which we just removed it from)\n        const originZoneItems = origShadowDz === originDropZone ? items : [...dzToConfig.get(originDropZone).items];\n        originZoneItems.splice(originIndex, 0, shadowElData);\n        dispatchConsiderEvent(originDropZone, originZoneItems, {\n            trigger: TRIGGERS.DRAGGED_LEFT_ALL,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity\n    dispatchConsiderEvent(e.currentTarget, items, {\n        trigger: TRIGGERS.DRAGGED_LEFT,\n        id: draggedElData[ITEM_ID_KEY],\n        source: SOURCES.POINTER\n    });\n}\nfunction handleDraggedIsOverIndex(e) {\n    printDebug(() => [\"dragged is over index\", e.currentTarget, e.detail]);\n    const {items: originalItems, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const items = [...originalItems];\n    isDraggedOutsideOfAnyDz = false;\n    const {index} = e.detail.indexObj;\n    const shadowElIdx = findShadowElementIdx(items);\n    if (shadowElIdx !== -1) {\n        items.splice(shadowElIdx, 1);\n    }\n    items.splice(index, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\n// Global mouse/touch-events handlers\nfunction handleMouseMove(e) {\n    e.preventDefault();\n    const c = e.touches ? e.touches[0] : e;\n    currentMousePosition = {x: c.clientX, y: c.clientY};\n    draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${\n        currentMousePosition.y - dragStartMousePosition.y\n    }px, 0)`;\n}\n\nfunction handleDrop() {\n    printDebug(() => \"dropped\");\n    finalizingPreviousDrag = true;\n    // cleanup\n    window.removeEventListener(\"mousemove\", handleMouseMove);\n    window.removeEventListener(\"touchmove\", handleMouseMove);\n    window.removeEventListener(\"mouseup\", handleDrop);\n    window.removeEventListener(\"touchend\", handleDrop);\n    unWatchDraggedElement();\n    moveDraggedElementToWasDroppedState(draggedEl);\n\n    if (!shadowElDropZone) {\n        printDebug(() => \"element was dropped right after it left origin but before entering somewhere else\");\n        shadowElDropZone = originDropZone;\n    }\n    printDebug(() => [\"dropped in dz\", shadowElDropZone]);\n    let {items, type} = dzToConfig.get(shadowElDropZone);\n    styleInactiveDropZones(\n        typeToDropZones.get(type),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    let shadowElIdx = findShadowElementIdx(items);\n    // the handler might remove the shadow element, ex: dragula like copy on drag\n    if (shadowElIdx === -1) {\n        if (shadowElDropZone === originDropZone) {\n            shadowElIdx = originIndex;\n        }\n    }\n\n    items = items.map(item => (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item));\n    function finalizeWithinZone() {\n        unlockOriginDzMinDimensions();\n        dispatchFinalizeEvent(shadowElDropZone, items, {\n            trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n        if (shadowElDropZone !== originDropZone) {\n            // letting the origin drop zone know the element was permanently taken away\n            dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {\n                trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n                id: draggedElData[ITEM_ID_KEY],\n                source: SOURCES.POINTER\n            });\n        }\n        if (shadowElIdx !== -1) unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);\n        cleanupPostDrop();\n    }\n    animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);\n}\n\n// helper function for handleDrop\nfunction animateDraggedToFinalPosition(shadowElIdx, callback) {\n    const shadowElRect =\n        shadowElIdx > -1 ? getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]) : getBoundingRectNoTransforms(shadowElDropZone);\n    const newTransform = {\n        x: shadowElRect.left - parseFloat(draggedEl.style.left),\n        y: shadowElRect.top - parseFloat(draggedEl.style.top)\n    };\n    const {dropAnimationDurationMs} = dzToConfig.get(shadowElDropZone);\n    const transition = `transform ${dropAnimationDurationMs}ms ease`;\n    draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + \",\" + transition : transition;\n    draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;\n    window.setTimeout(callback, dropAnimationDurationMs);\n}\n\nfunction scheduleDZForRemovalAfterDrop(dz, destroy) {\n    scheduledForRemovalAfterDrop.push({dz, destroy});\n    window.requestAnimationFrame(() => {\n        hideElement(dz);\n        document.body.appendChild(dz);\n    });\n}\n/* cleanup */\nfunction cleanupPostDrop() {\n    draggedEl.remove();\n    originalDragTarget.remove();\n    if (scheduledForRemovalAfterDrop.length) {\n        printDebug(() => [\"will destroy zones that were removed during drag\", scheduledForRemovalAfterDrop]);\n        scheduledForRemovalAfterDrop.forEach(({dz, destroy}) => {\n            destroy();\n            dz.remove();\n        });\n        scheduledForRemovalAfterDrop = [];\n    }\n    draggedEl = undefined;\n    originalDragTarget = undefined;\n    draggedElData = undefined;\n    draggedElType = undefined;\n    originDropZone = undefined;\n    originIndex = undefined;\n    shadowElData = undefined;\n    shadowElDropZone = undefined;\n    dragStartMousePosition = undefined;\n    currentMousePosition = undefined;\n    isWorkingOnPreviousDrag = false;\n    finalizingPreviousDrag = false;\n    unlockOriginDzMinDimensions = undefined;\n    isDraggedOutsideOfAnyDz = false;\n}\n\nexport function dndzone(node, options) {\n    let initialized = false;\n    const config = {\n        items: undefined,\n        type: undefined,\n        flipDurationMs: 0,\n        dragDisabled: false,\n        morphDisabled: false,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        transformDraggedElement: () => {},\n        centreDraggedOnCursor: false\n    };\n    printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, {node}]);\n    let elToIdx = new Map();\n\n    function addMaybeListeners() {\n        window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleFalseAlarm, {passive: false});\n        window.addEventListener(\"touchend\", handleFalseAlarm, {passive: false});\n    }\n    function removeMaybeListeners() {\n        window.removeEventListener(\"mousemove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"touchmove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"mouseup\", handleFalseAlarm);\n        window.removeEventListener(\"touchend\", handleFalseAlarm);\n    }\n    function handleFalseAlarm() {\n        removeMaybeListeners();\n        originalDragTarget = undefined;\n        dragStartMousePosition = undefined;\n        currentMousePosition = undefined;\n    }\n\n    function handleMouseMoveMaybeDragStart(e) {\n        e.preventDefault();\n        const c = e.touches ? e.touches[0] : e;\n        currentMousePosition = {x: c.clientX, y: c.clientY};\n        if (\n            Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n            Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n        ) {\n            removeMaybeListeners();\n            handleDragStart();\n        }\n    }\n    function handleMouseDown(e) {\n        // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense\n        if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {\n            printDebug(() => \"won't initiate drag on a nested input element\");\n            return;\n        }\n        // prevents responding to any button but left click which equals 0 (which is falsy)\n        if (e.button) {\n            printDebug(() => `ignoring none left click button: ${e.button}`);\n            return;\n        }\n        if (isWorkingOnPreviousDrag) {\n            printDebug(() => \"cannot start a new drag before finalizing previous one\");\n            return;\n        }\n        e.stopPropagation();\n        const c = e.touches ? e.touches[0] : e;\n        dragStartMousePosition = {x: c.clientX, y: c.clientY};\n        currentMousePosition = {...dragStartMousePosition};\n        originalDragTarget = e.currentTarget;\n        addMaybeListeners();\n    }\n\n    function handleDragStart() {\n        printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);\n        isWorkingOnPreviousDrag = true;\n\n        // initialising globals\n        const currentIdx = elToIdx.get(originalDragTarget);\n        originIndex = currentIdx;\n        originDropZone = originalDragTarget.parentElement;\n        /** @type {ShadowRoot | HTMLDocument | Element } */\n        const rootNode = originDropZone.closest(\"dialog\") || originDropZone.getRootNode();\n        const originDropZoneRoot = rootNode.body || rootNode;\n        const {items: originalItems, type, centreDraggedOnCursor} = config;\n        const items = [...originalItems];\n        draggedElData = items[currentIdx];\n        draggedElType = type;\n        shadowElData = createShadowElData(draggedElData);\n\n        // creating the draggable element\n        draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);\n        originalDragTarget.setAttribute(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, true);\n\n        // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it\n        function keepOriginalElementInDom() {\n            if (!draggedEl.parentElement) {\n                originDropZoneRoot.appendChild(draggedEl);\n                // to prevent the outline from disappearing\n                draggedEl.focus();\n                watchDraggedElement();\n                hideElement(originalDragTarget);\n                originDropZoneRoot.appendChild(originalDragTarget);\n                // after the removal of the original element we can give the shadow element the original item id so that the host zone can find it and render it correctly if it does lookups by id\n                shadowElData[ITEM_ID_KEY] = draggedElData[ITEM_ID_KEY];\n            } else {\n                window.requestAnimationFrame(keepOriginalElementInDom);\n            }\n        }\n        window.requestAnimationFrame(keepOriginalElementInDom);\n\n        styleActiveDropZones(\n            Array.from(typeToDropZones.get(config.type)).filter(dz => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n\n        // removing the original element by removing its data entry\n        items.splice(currentIdx, 1, shadowElData);\n        unlockOriginDzMinDimensions = preventShrinking(originDropZone);\n\n        dispatchConsiderEvent(originDropZone, items, {trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n\n        // handing over to global handlers - starting to watch the element\n        window.addEventListener(\"mousemove\", handleMouseMove, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMove, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleDrop, {passive: false});\n        window.addEventListener(\"touchend\", handleDrop, {passive: false});\n    }\n\n    function configure({\n        items = undefined,\n        flipDurationMs: dropAnimationDurationMs = 0,\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        morphDisabled = false,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        transformDraggedElement = () => {},\n        centreDraggedOnCursor = false\n    }) {\n        config.dropAnimationDurationMs = dropAnimationDurationMs;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.morphDisabled = morphDisabled;\n        config.transformDraggedElement = transformDraggedElement;\n        config.centreDraggedOnCursor = centreDraggedOnCursor;\n\n        // realtime update for dropTargetStyle\n        if (\n            initialized &&\n            isWorkingOnPreviousDrag &&\n            !finalizingPreviousDrag &&\n            (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) ||\n                !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))\n        ) {\n            styleInactiveDropZones(\n                [node],\n                () => config.dropTargetStyle,\n                () => dropTargetClasses\n            );\n            styleActiveDropZones(\n                [node],\n                () => dropTargetStyle,\n                () => dropTargetClasses\n            );\n        }\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = [...dropTargetClasses];\n\n        // realtime update for dropFromOthersDisabled\n        function getConfigProp(dz, propName) {\n            return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];\n        }\n        if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {\n            if (dropFromOthersDisabled) {\n                styleInactiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            } else {\n                styleActiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            }\n        }\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n\n        dzToConfig.set(node, config);\n        registerDropZone(node, newType);\n        const shadowElIdx = findShadowElementIdx(config.items);\n        for (let idx = 0; idx < node.children.length; idx++) {\n            const draggableEl = node.children[idx];\n            styleDraggable(draggableEl, dragDisabled);\n            if (idx === shadowElIdx) {\n                config.transformDraggedElement(draggedEl, draggedElData, idx);\n                if (!morphDisabled) {\n                    morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);\n                }\n                decorateShadowEl(draggableEl);\n                continue;\n            }\n            draggableEl.removeEventListener(\"mousedown\", elToMouseDownListener.get(draggableEl));\n            draggableEl.removeEventListener(\"touchstart\", elToMouseDownListener.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"mousedown\", handleMouseDown);\n                draggableEl.addEventListener(\"touchstart\", handleMouseDown);\n                elToMouseDownListener.set(draggableEl, handleMouseDown);\n            }\n            // updating the idx\n            elToIdx.set(draggableEl, idx);\n\n            if (!initialized) {\n                initialized = true;\n            }\n        }\n    }\n    configure(options);\n\n    return {\n        update: newOptions => {\n            printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            function destroyDz() {\n                printDebug(() => \"pointer dndzone will destroy\");\n                unregisterDropZone(node, dzToConfig.get(node).type);\n                dzToConfig.delete(node);\n            }\n            if (isWorkingOnPreviousDrag && !node.closest(`[${ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE}]`)) {\n                printDebug(() => \"pointer dndzone will be scheduled for destruction\");\n                scheduleDZForRemovalAfterDrop(node, destroyDz);\n            } else {\n                destroyDz();\n            }\n        }\n    };\n}\n","import {isOnServer} from \"../constants\";\n\nconst INSTRUCTION_IDs = {\n    DND_ZONE_ACTIVE: \"dnd-zone-active\",\n    DND_ZONE_DRAG_DISABLED: \"dnd-zone-drag-disabled\"\n};\nconst ID_TO_INSTRUCTION = {\n    [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: \"Tab to one the items and press space-bar or enter to start dragging it\",\n    [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: \"This is a disabled drag and drop list\"\n};\n\nconst ALERT_DIV_ID = \"dnd-action-aria-alert\";\nlet alertsDiv;\n\nfunction initAriaOnBrowser() {\n    if (alertsDiv) {\n        // it is already initialized\n        return;\n    }\n    // setting the dynamic alerts\n    alertsDiv = document.createElement(\"div\");\n    (function initAlertsDiv() {\n        alertsDiv.id = ALERT_DIV_ID;\n        // tab index -1 makes the alert be read twice on chrome for some reason\n        //alertsDiv.tabIndex = -1;\n        alertsDiv.style.position = \"fixed\";\n        alertsDiv.style.bottom = \"0\";\n        alertsDiv.style.left = \"0\";\n        alertsDiv.style.zIndex = \"-5\";\n        alertsDiv.style.opacity = \"0\";\n        alertsDiv.style.height = \"0\";\n        alertsDiv.style.width = \"0\";\n        alertsDiv.setAttribute(\"role\", \"alert\");\n    })();\n    document.body.prepend(alertsDiv);\n\n    // setting the instructions\n    Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));\n}\n\n/**\n * Initializes the static aria instructions so they can be attached to zones\n * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server\n */\nexport function initAria() {\n    if (isOnServer) return null;\n    if (document.readyState === \"complete\") {\n        initAriaOnBrowser();\n    } else {\n        window.addEventListener(\"DOMContentLoaded\", initAriaOnBrowser);\n    }\n    return {...INSTRUCTION_IDs};\n}\n\n/**\n * Removes all the artifacts (dom elements) added by this module\n */\nexport function destroyAria() {\n    if (isOnServer || !alertsDiv) return;\n    Object.keys(ID_TO_INSTRUCTION).forEach(id => document.getElementById(id)?.remove());\n    alertsDiv.remove();\n    alertsDiv = undefined;\n}\n\nfunction instructionToHiddenDiv(id, txt) {\n    const div = document.createElement(\"div\");\n    div.id = id;\n    div.innerHTML = `<p>${txt}</p>`;\n    div.style.display = \"none\";\n    div.style.position = \"fixed\";\n    div.style.zIndex = \"-5\";\n    return div;\n}\n\n/**\n * Will make the screen reader alert the provided text to the user\n * @param {string} txt\n */\nexport function alertToScreenReader(txt) {\n    if (isOnServer) return;\n    if (!alertsDiv) {\n        initAriaOnBrowser();\n    }\n    alertsDiv.innerHTML = \"\";\n    const alertText = document.createTextNode(txt);\n    alertsDiv.appendChild(alertText);\n    // this is needed for Safari\n    alertsDiv.style.display = \"none\";\n    alertsDiv.style.display = \"inline\";\n}\n","import {decrementActiveDropZoneCount, incrementActiveDropZoneCount, ITEM_ID_KEY, SOURCES, TRIGGERS} from \"./constants\";\nimport {styleActiveDropZones, styleInactiveDropZones} from \"./helpers/styler\";\nimport {dispatchConsiderEvent, dispatchFinalizeEvent} from \"./helpers/dispatcher\";\nimport {initAria, alertToScreenReader, destroyAria} from \"./helpers/aria\";\nimport {toString} from \"./helpers/util\";\nimport {printDebug} from \"./constants\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet isDragging = false;\nlet draggedItemType;\nlet focusedDz;\nlet focusedDzLabel = \"\";\nlet focusedItem;\nlet focusedItemId;\nlet focusedItemLabel = \"\";\nconst allDragTargets = new WeakSet();\nconst elToKeyDownListeners = new WeakMap();\nconst elToFocusListeners = new WeakMap();\nconst dzToHandles = new Map();\nconst dzToConfig = new Map();\nconst typeToDropZones = new Map();\n\n/* TODO (potentially)\n * what's the deal with the black border of voice-reader not following focus?\n * maybe keep focus on the last dragged item upon drop?\n */\n\nlet INSTRUCTION_IDs;\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"adding global keydown and click handlers\");\n        INSTRUCTION_IDs = initAria();\n        window.addEventListener(\"keydown\", globalKeyDownHandler);\n        window.addEventListener(\"click\", globalClickHandler);\n    }\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    printDebug(() => \"unregistering drop-zone\");\n    if (focusedDz === dropZoneEl) {\n        handleDrop();\n    }\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"removing global keydown and click handlers\");\n        window.removeEventListener(\"keydown\", globalKeyDownHandler);\n        window.removeEventListener(\"click\", globalClickHandler);\n        INSTRUCTION_IDs = undefined;\n        destroyAria();\n    }\n}\n\nfunction globalKeyDownHandler(e) {\n    if (!isDragging) return;\n    switch (e.key) {\n        case \"Escape\": {\n            handleDrop();\n            break;\n        }\n    }\n}\n\nfunction globalClickHandler() {\n    if (!isDragging) return;\n    if (!allDragTargets.has(document.activeElement)) {\n        printDebug(() => \"clicked outside of any draggable\");\n        handleDrop();\n    }\n}\n\nfunction handleZoneFocus(e) {\n    printDebug(() => \"zone focus\");\n    if (!isDragging) return;\n    const newlyFocusedDz = e.currentTarget;\n    if (newlyFocusedDz === focusedDz) return;\n\n    focusedDzLabel = newlyFocusedDz.getAttribute(\"aria-label\") || \"\";\n    const {items: originItems} = dzToConfig.get(focusedDz);\n    const originItem = originItems.find(item => item[ITEM_ID_KEY] === focusedItemId);\n    const originIdx = originItems.indexOf(originItem);\n    const itemToMove = originItems.splice(originIdx, 1)[0];\n    const {items: targetItems, autoAriaDisabled} = dzToConfig.get(newlyFocusedDz);\n    if (\n        newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top ||\n        newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left\n    ) {\n        targetItems.push(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);\n        }\n    } else {\n        targetItems.unshift(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);\n        }\n    }\n    const dzFrom = focusedDz;\n    dispatchFinalizeEvent(dzFrom, originItems, {trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD});\n    dispatchFinalizeEvent(newlyFocusedDz, targetItems, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n    focusedDz = newlyFocusedDz;\n}\n\nfunction triggerAllDzsUpdate() {\n    dzToHandles.forEach(({update}, dz) => update(dzToConfig.get(dz)));\n}\n\nfunction handleDrop(dispatchConsider = true) {\n    printDebug(() => \"drop\");\n    if (!dzToConfig.get(focusedDz).autoAriaDisabled) {\n        alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);\n    }\n    if (allDragTargets.has(document.activeElement)) {\n        document.activeElement.blur();\n    }\n    if (dispatchConsider) {\n        dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {\n            trigger: TRIGGERS.DRAG_STOPPED,\n            id: focusedItemId,\n            source: SOURCES.KEYBOARD\n        });\n    }\n    styleInactiveDropZones(\n        typeToDropZones.get(draggedItemType),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    focusedItem = null;\n    focusedItemId = null;\n    focusedItemLabel = \"\";\n    draggedItemType = null;\n    focusedDz = null;\n    focusedDzLabel = \"\";\n    isDragging = false;\n    triggerAllDzsUpdate();\n}\n//////\nexport function dndzone(node, options) {\n    const config = {\n        items: undefined,\n        type: undefined,\n        dragDisabled: false,\n        zoneTabIndex: 0,\n        zoneItemTabIndex: 0,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        autoAriaDisabled: false\n    };\n\n    function swap(arr, i, j) {\n        if (arr.length <= 1) return;\n        arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);\n    }\n\n    function handleKeyDown(e) {\n        printDebug(() => [\"handling key down\", e.key]);\n        switch (e.key) {\n            case \"Enter\":\n            case \" \": {\n                // we don't want to affect nested input elements or clickable elements\n                if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {\n                    return;\n                }\n                e.preventDefault(); // preventing scrolling on spacebar\n                e.stopPropagation();\n                if (isDragging) {\n                    // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?\n                    handleDrop();\n                } else {\n                    // drag start\n                    handleDragStart(e);\n                }\n                break;\n            }\n            case \"ArrowDown\":\n            case \"ArrowRight\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow down\", idx]);\n                if (idx < children.length - 1) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx + 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowLeft\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow up\", idx]);\n                if (idx > 0) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx - 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n        }\n    }\n    function handleDragStart(e) {\n        printDebug(() => \"drag start\");\n        setCurrentFocusedItem(e.currentTarget);\n        focusedDz = node;\n        draggedItemType = config.type;\n        isDragging = true;\n        const dropTargets = Array.from(typeToDropZones.get(config.type)).filter(dz => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);\n        styleActiveDropZones(\n            dropTargets,\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n        if (!config.autoAriaDisabled) {\n            let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;\n            if (dropTargets.length > 1) {\n                msg += `, or tab to another list in order to move the item into it`;\n            }\n            alertToScreenReader(msg);\n        }\n        dispatchConsiderEvent(node, dzToConfig.get(node).items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});\n        triggerAllDzsUpdate();\n    }\n\n    function handleClick(e) {\n        if (!isDragging) return;\n        if (e.currentTarget === focusedItem) return;\n        e.stopPropagation();\n        handleDrop(false);\n        handleDragStart(e);\n    }\n    function setCurrentFocusedItem(draggableEl) {\n        const {items} = dzToConfig.get(node);\n        const children = Array.from(node.children);\n        const focusedItemIdx = children.indexOf(draggableEl);\n        focusedItem = draggableEl;\n        focusedItem.tabIndex = config.zoneItemTabIndex;\n        focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];\n        focusedItemLabel = children[focusedItemIdx].getAttribute(\"aria-label\") || \"\";\n    }\n\n    function configure({\n        items = [],\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        zoneTabIndex = 0,\n        zoneItemTabIndex = 0,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        autoAriaDisabled = false\n    }) {\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n        config.zoneTabIndex = zoneTabIndex;\n        config.zoneItemTabIndex = zoneItemTabIndex;\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = dropTargetClasses;\n        config.autoAriaDisabled = autoAriaDisabled;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        if (!autoAriaDisabled) {\n            node.setAttribute(\"aria-disabled\", dragDisabled);\n            node.setAttribute(\"role\", \"list\");\n            node.setAttribute(\"aria-describedby\", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);\n        }\n        dzToConfig.set(node, config);\n\n        if (isDragging) {\n            node.tabIndex =\n                node === focusedDz ||\n                focusedItem.contains(node) ||\n                config.dropFromOthersDisabled ||\n                (focusedDz && config.type !== dzToConfig.get(focusedDz).type)\n                    ? -1\n                    : 0;\n        } else {\n            node.tabIndex = config.zoneTabIndex;\n        }\n\n        node.addEventListener(\"focus\", handleZoneFocus);\n\n        for (let i = 0; i < node.children.length; i++) {\n            const draggableEl = node.children[i];\n            allDragTargets.add(draggableEl);\n            draggableEl.tabIndex = isDragging ? -1 : config.zoneItemTabIndex;\n            if (!autoAriaDisabled) {\n                draggableEl.setAttribute(\"role\", \"listitem\");\n            }\n            draggableEl.removeEventListener(\"keydown\", elToKeyDownListeners.get(draggableEl));\n            draggableEl.removeEventListener(\"click\", elToFocusListeners.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"keydown\", handleKeyDown);\n                elToKeyDownListeners.set(draggableEl, handleKeyDown);\n                draggableEl.addEventListener(\"click\", handleClick);\n                elToFocusListeners.set(draggableEl, handleClick);\n            }\n            if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {\n                printDebug(() => [\"focusing on\", {i, focusedItemId}]);\n                // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer\n                focusedItem = draggableEl;\n                focusedItem.tabIndex = config.zoneItemTabIndex;\n                // without this the element loses focus if it moves backwards in the list\n                draggableEl.focus();\n            }\n        }\n    }\n    configure(options);\n\n    const handles = {\n        update: newOptions => {\n            printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            printDebug(() => \"keyboard dndzone will destroy\");\n            unregisterDropZone(node, config.type);\n            dzToConfig.delete(node);\n            dzToHandles.delete(node);\n        }\n    };\n    dzToHandles.set(node, handles);\n    return handles;\n}\n","import {dndzone as pointerDndZone} from \"./pointerAction\";\nimport {dndzone as keyboardDndZone} from \"./keyboardAction\";\nimport {ITEM_ID_KEY, SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME} from \"./constants\";\nimport {toString} from \"./helpers/util\";\n\n/**\n * A custom action to turn any container to a dnd zone and all of its direct children to draggables\n * Supports mouse, touch and keyboard interactions.\n * Dispatches two events that the container is expected to react to by modifying its list of items,\n * which will then feed back in to this action via the update function\n *\n * @typedef {object} Options\n * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block\n * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type\n * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero\n * @property {boolean} [dragDisabled]\n * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions\n * @property {boolean} [dropFromOthersDisabled]\n * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging\n * @property {number} [zoneItemTabIndex] - set the tabindex of the list container items when not dragging\n * @property {object} [dropTargetStyle]\n * @property {string[]} [dropTargetClasses]\n * @property {function} [transformDraggedElement]\n * @param {HTMLElement} node - the element to enhance\n * @param {Options} options\n * @return {{update: function, destroy: function}}\n */\nexport function dndzone(node, options) {\n    if (shouldIgnoreZone(node)) {\n        return {\n            update: () => {},\n            destroy: () => {}\n        };\n    }\n    validateOptions(options);\n    const pointerZone = pointerDndZone(node, options);\n    const keyboardZone = keyboardDndZone(node, options);\n    return {\n        update: newOptions => {\n            validateOptions(newOptions);\n            pointerZone.update(newOptions);\n            keyboardZone.update(newOptions);\n        },\n        destroy: () => {\n            pointerZone.destroy();\n            keyboardZone.destroy();\n        }\n    };\n}\n\n/**\n * If the user marked something in the ancestry of our node as shadow element, we can ignore it\n * We need the user to mark it for us because svelte updates the action from deep to shallow (but renders top down)\n * @param {HTMLElement} node\n * @return {boolean}\n */\nfunction shouldIgnoreZone(node) {\n    return !!node.closest(`[${SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME}=\"true\"]`);\n}\n\nfunction validateOptions(options) {\n    /*eslint-disable*/\n    const {\n        items,\n        flipDurationMs,\n        type,\n        dragDisabled,\n        morphDisabled,\n        dropFromOthersDisabled,\n        zoneTabIndex,\n        zoneItemTabIndex,\n        dropTargetStyle,\n        dropTargetClasses,\n        transformDraggedElement,\n        autoAriaDisabled,\n        centreDraggedOnCursor,\n        ...rest\n    } = options;\n    /*eslint-enable*/\n    if (Object.keys(rest).length > 0) {\n        console.warn(`dndzone will ignore unknown options`, rest);\n    }\n    if (!items) {\n        throw new Error(\"no 'items' key provided to dndzone\");\n    }\n    const itemWithMissingId = items.find(item => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));\n    if (itemWithMissingId) {\n        throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);\n    }\n    if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {\n        throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);\n    }\n    if (zoneTabIndex && !isInt(zoneTabIndex)) {\n        throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);\n    }\n    if (zoneItemTabIndex && !isInt(zoneItemTabIndex)) {\n        throw new Error(`zoneItemTabIndex should be a number but instead it is a ${typeof zoneItemTabIndex}, ${toString(zoneItemTabIndex)}`);\n    }\n}\n\nfunction isInt(value) {\n    return (\n        !isNaN(value) &&\n        (function (x) {\n            return (x | 0) === x;\n        })(parseFloat(value))\n    );\n}\n","import { cubicOut } from '../easing/index.mjs';\nimport { is_function } from '../internal/index.mjs';\n\nfunction flip(node, { from, to }, params = {}) {\n    const style = getComputedStyle(node);\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);\n    const dx = (from.left + from.width * ox / to.width) - (to.left + ox);\n    const dy = (from.top + from.height * oy / to.height) - (to.top + oy);\n    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;\n    return {\n        delay,\n        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,\n        easing,\n        css: (t, u) => {\n            const x = u * dx;\n            const y = u * dy;\n            const sx = t + u * from.width / to.width;\n            const sy = t + u * from.height / to.height;\n            return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;\n        }\n    };\n}\n\nexport { flip };\n"],"names":["toString","object","getDepth","node","_getDepth","countSoFar","areObjectsShallowEqual","objA","objB","keyA","areArraysShallowEqualSameOrder","arrA","arrB","i","INTERVAL_MS","TOLERANCE_PX","next","observe","draggedEl","dropZones","intervalMs","multiScroller","lastDropZoneFound","lastIndexFound","lastIsDraggedInADropZone","lastCentrePositionOfDragged","dropZonesFromDeepToShallow","dz1","dz2","andNow","currentCenterOfDragged","findCenterOfElement","scrolled","isElementOffDocument","dispatchDraggedLeftDocument","isDraggedInADropZone","dz","resetIndexesCache","indexObj","findWouldBeIndex","index","dispatchDraggedElementLeftContainerForAnother","dispatchDraggedElementEnteredContainer","dispatchDraggedElementIsOverIndex","dispatchDraggedElementLeftContainerForNone","unobserve","SCROLL_ZONE_PX","makeScroller","scrollingInfo","resetScrolling","scrollContainer","containerEl","directionObj","stepPx","calcScrollStepPx","distancePx","scrollIfNeeded","pointer","elementToScroll","distances","calcInnerDistancesBetweenPointAndSidesOfElement","isAlreadyScrolling","scrollingVertically","scrollingHorizontally","point","el","rect","isPointInsideRect","createMultiScroller","baseElementsForScrolling","getPointerPosition","scrollingContainersSet","findRelevantScrollContainers","scrollingContainersDeepToShallow","tick","mousePosition","scrollContainersUnderCursor","findScrollableParents","element","scrollableContainers","parent","overflow","o","scrollingContainers","container","svelteNodeClone","cloned","values","elIsSelect","selects","select","clonedSelects","value","optionEl","elIsCanvas","canvases","clonedCanvases","canvas","clonedCanvas","TRANSITION_DURATION_SECONDS","trs","property","createDraggedElementFrom","originalElement","positionCenterOnXY","copyStylesFromTo","DRAGGED_ELEMENT_ID","elTopPx","elLeftPx","center","findCenter","moveDraggedElementToWasDroppedState","morphDraggedElementToBeLike","copyFromEl","currentMouseX","currentMouseY","newRect","draggedElRect","widthChange","heightChange","relativeDistanceOfMousePointerFromDraggedSides","getFeatureFlag","FEATURE_FLAG_NAMES","copyToEl","computedStyle","s","styleDraggable","draggableEl","dragDisabled","hideElement","dragTarget","decorateShadowEl","shadowEl","SHADOW_ELEMENT_ATTRIBUTE_NAME","unDecorateShadowElement","styleActiveDropZones","getStyles","getClasses","styles","style","c","styleInactiveDropZones","preventShrinking","originalMinHeight","originalMinWidth","DEFAULT_DROP_ZONE_TYPE","MIN_OBSERVATION_INTERVAL_MS","DISABLED_OBSERVATION_INTERVAL_MS","MIN_MOVEMENT_BEFORE_DRAG_START_PX","DEFAULT_DROP_TARGET_STYLE","ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE","originalDragTarget","draggedElData","draggedElType","originDropZone","originIndex","shadowElData","shadowElDropZone","dragStartMousePosition","currentMousePosition","isWorkingOnPreviousDrag","finalizingPreviousDrag","unlockOriginDzMinDimensions","isDraggedOutsideOfAnyDz","scheduledForRemovalAfterDrop","typeToDropZones","dzToConfig","elToMouseDownListener","registerDropZone","dropZoneEl","type","incrementActiveDropZoneCount","unregisterDropZone","decrementActiveDropZoneCount","watchDraggedElement","DRAGGED_ENTERED_EVENT_NAME","handleDraggedEntered","DRAGGED_LEFT_EVENT_NAME","handleDraggedLeft","DRAGGED_OVER_INDEX_EVENT_NAME","handleDraggedIsOverIndex","DRAGGED_LEFT_DOCUMENT_EVENT_NAME","handleDrop","setIntervalMs","observationIntervalMs","unWatchDraggedElement","findShadowElementIdx","items","item","SHADOW_ITEM_MARKER_PROPERTY_NAME","createShadowElData","ITEM_ID_KEY","SHADOW_PLACEHOLDER_ITEM_ID","dropFromOthersDisabled","newOriginZoneItems","dispatchConsiderEvent","TRIGGERS","SOURCES","isProximityBased","shadowElIdx","originalItems","origShadowDz","theOtherDz","DRAGGED_LEFT_TYPES","originZoneItems","handleMouseMove","finalizeWithinZone","dispatchFinalizeEvent","cleanupPostDrop","animateDraggedToFinalPosition","callback","shadowElRect","getBoundingRectNoTransforms","newTransform","dropAnimationDurationMs","transition","scheduleDZForRemovalAfterDrop","destroy","dndzone","options","initialized","config","elToIdx","addMaybeListeners","handleMouseMoveMaybeDragStart","handleFalseAlarm","removeMaybeListeners","e","handleDragStart","handleMouseDown","currentIdx","rootNode","originDropZoneRoot","centreDraggedOnCursor","keepOriginalElementInDom","configure","newType","morphDisabled","dropTargetStyle","dropTargetClasses","transformDraggedElement","getConfigProp","propName","idx","newOptions","destroyDz","INSTRUCTION_IDs","ID_TO_INSTRUCTION","ALERT_DIV_ID","alertsDiv","initAriaOnBrowser","id","txt","instructionToHiddenDiv","initAria","isOnServer","destroyAria","_a","div","alertToScreenReader","alertText","isDragging","draggedItemType","focusedDz","focusedDzLabel","focusedItem","focusedItemId","focusedItemLabel","allDragTargets","elToKeyDownListeners","elToFocusListeners","dzToHandles","globalKeyDownHandler","globalClickHandler","handleZoneFocus","newlyFocusedDz","originItems","originItem","originIdx","itemToMove","targetItems","autoAriaDisabled","triggerAllDzsUpdate","update","dispatchConsider","swap","arr","j","handleKeyDown","children","setCurrentFocusedItem","dropTargets","msg","handleClick","focusedItemIdx","zoneTabIndex","zoneItemTabIndex","handles","shouldIgnoreZone","validateOptions","pointerZone","pointerDndZone","keyboardZone","keyboardDndZone","SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME","flipDurationMs","rest","itemWithMissingId","isInt","x","flip","from","to","params","transform","ox","oy","dx","dy","delay","duration","d","easing","cubicOut","is_function","t","u","y","sx","sy"],"mappings":"2aAIO,SAASA,GAASC,EAAQ,CAC7B,OAAO,KAAK,UAAUA,EAAQ,KAAM,CAAC,CACzC,CAOO,SAASC,GAASC,EAAM,CAC3B,GAAI,CAACA,EACD,MAAM,IAAI,MAAM,kCAAkC,EAEtD,OAAOC,GAAUD,EAAM,CAAC,CAC5B,CACA,SAASC,GAAUD,EAAME,EAAa,EAAG,CACrC,OAAKF,EAAK,cAGHC,GAAUD,EAAK,cAAeE,EAAa,CAAC,EAFxCA,EAAa,CAG5B,CAQO,SAASC,GAAuBC,EAAMC,EAAM,CAC/C,GAAI,OAAO,KAAKD,CAAI,EAAE,SAAW,OAAO,KAAKC,CAAI,EAAE,OAC/C,MAAO,GAEX,UAAWC,KAAQF,EACf,GAAI,CAAC,CAAE,EAAC,eAAe,KAAKC,EAAMC,CAAI,GAAKD,EAAKC,CAAI,IAAMF,EAAKE,CAAI,EAC/D,MAAO,GAGf,MAAO,EACX,CAQO,SAASC,GAA+BC,EAAMC,EAAM,CACvD,GAAID,EAAK,SAAWC,EAAK,OACrB,MAAO,GAEX,QAASC,EAAI,EAAGA,EAAIF,EAAK,OAAQE,IAC7B,GAAIF,EAAKE,CAAC,IAAMD,EAAKC,CAAC,EAClB,MAAO,GAGf,MAAO,EACX,CChDA,MAAMC,GAAc,IACdC,GAAe,GACrB,IAAIC,GASG,SAASC,GAAQC,EAAWC,EAAWC,EAAaN,GAAaO,EAAe,CAEnF,IAAIC,EACAC,EACAC,EAA2B,GAC3BC,EAEJ,MAAMC,EAA6B,MAAM,KAAKP,CAAS,EAAE,KAAK,CAACQ,EAAKC,IAAQ1B,GAAS0B,CAAG,EAAI1B,GAASyB,CAAG,CAAC,EAKzG,SAASE,GAAS,CACd,MAAMC,EAAyBC,GAAoBb,CAAS,EACtDc,EAAWX,EAAc,sBAE/B,GACI,CAACW,GACDP,GACA,KAAK,IAAIA,EAA4B,EAAIK,EAAuB,CAAC,EAAIf,IACrE,KAAK,IAAIU,EAA4B,EAAIK,EAAuB,CAAC,EAAIf,GACvE,CACEC,GAAO,OAAO,WAAWa,EAAQT,CAAU,EAC3C,MACH,CACD,GAAIa,GAAqBf,CAAS,EAAG,CAEjCgB,GAA4BhB,CAAS,EACrC,MACH,CAEDO,EAA8BK,EAE9B,IAAIK,EAAuB,GAC3B,UAAWC,KAAMV,EAA4B,CACrCM,GAAUK,KACd,MAAMC,EAAWC,GAAiBrB,EAAWkB,CAAE,EAC/C,GAAIE,IAAa,KAEb,SAEJ,KAAM,CAAC,MAAAE,CAAK,EAAIF,EAChBH,EAAuB,GAEnBC,IAAOd,GACPA,GAAqBmB,GAA8CnB,EAAmBJ,EAAWkB,CAAE,EACnGM,GAAuCN,EAAIE,EAAUpB,CAAS,EAC9DI,EAAoBc,GACbI,IAAUjB,IACjBoB,GAAkCP,EAAIE,EAAUpB,CAAS,EACzDK,EAAiBiB,GAGrB,KACH,CAEG,CAACL,GAAwBX,GAA4BF,GACrDsB,GAA2CtB,EAAmBJ,CAAS,EACvEI,EAAoB,OACpBC,EAAiB,OACjBC,EAA2B,IAE3BA,EAA2B,GAE/BR,GAAO,OAAO,WAAWa,EAAQT,CAAU,CAC9C,CACDS,GACJ,CAGO,SAASgB,IAAY,CAExB,aAAa7B,EAAI,EACjBqB,IACJ,CChGA,MAAMS,EAAiB,GAMhB,SAASC,IAAe,CAC3B,IAAIC,EACJ,SAASC,GAAiB,CACtBD,EAAgB,CAAC,aAAc,OAAW,OAAQ,CAAC,CACtD,CACDC,IAEA,SAASC,EAAgBC,EAAa,CAClC,KAAM,CAAC,aAAAC,EAAc,OAAAC,CAAM,EAAIL,EAC3BI,IACAD,EAAY,SAASC,EAAa,EAAIC,EAAQD,EAAa,EAAIC,CAAM,EACrE,OAAO,sBAAsB,IAAMH,EAAgBC,CAAW,CAAC,EAEtE,CACD,SAASG,EAAiBC,EAAY,CAClC,OAAOT,EAAiBS,CAC3B,CASD,SAASC,EAAeC,EAASC,EAAiB,CAC9C,GAAI,CAACA,EACD,MAAO,GAEX,MAAMC,EAAYC,GAAgDH,EAASC,CAAe,EAC1F,GAAIC,IAAc,KACd,OAAAV,IACO,GAEX,MAAMY,EAAqB,CAAC,CAACb,EAAc,aAC3C,GAAI,CAACc,EAAqBC,CAAqB,EAAI,CAAC,GAAO,EAAK,EAkBhE,OAhBIL,EAAgB,aAAeA,EAAgB,eAC3CC,EAAU,OAASb,GACnBgB,EAAsB,GACtBd,EAAc,aAAe,CAAC,EAAG,EAAG,EAAG,CAAC,EACxCA,EAAc,OAASM,EAAiBK,EAAU,MAAM,GACjDA,EAAU,IAAMb,IACvBgB,EAAsB,GACtBd,EAAc,aAAe,CAAC,EAAG,EAAG,EAAG,EAAE,EACzCA,EAAc,OAASM,EAAiBK,EAAU,GAAG,GAErD,CAACE,GAAsBC,IAM3BJ,EAAgB,YAAcA,EAAgB,cAC1CC,EAAU,MAAQb,GAClBiB,EAAwB,GACxBf,EAAc,aAAe,CAAC,EAAG,EAAG,EAAG,CAAC,EACxCA,EAAc,OAASM,EAAiBK,EAAU,KAAK,GAChDA,EAAU,KAAOb,IACxBiB,EAAwB,GACxBf,EAAc,aAAe,CAAC,EAAG,GAAI,EAAG,CAAC,EACzCA,EAAc,OAASM,EAAiBK,EAAU,IAAI,GAEtD,CAACE,GAAsBE,IACvBb,EAAgBQ,CAAe,EACxB,KAGfT,IACO,GACV,CAED,MAAO,CACH,eAAAO,EACA,eAAAP,CACR,CACA,CAQA,SAASW,GAAgDI,EAAOC,EAAI,CAEhE,MAAMC,EACFD,IAAO,SAAS,iBACV,CACI,IAAK,EACL,OAAQ,OAAO,YACf,KAAM,EACN,MAAO,OAAO,UACjB,EACDA,EAAG,sBAAqB,EAClC,OAAKE,GAAkBH,EAAOE,CAAI,EAG3B,CACH,IAAKF,EAAM,EAAIE,EAAK,IACpB,OAAQA,EAAK,OAASF,EAAM,EAC5B,KAAMA,EAAM,EAAIE,EAAK,KACrB,MAAOA,EAAK,MAAQF,EAAM,CAClC,EAPe,IAQf,CCjGO,SAASI,GAAoBC,EAA2B,CAAE,EAAEC,EAAoB,CAEnF,MAAMC,EAAyBC,GAA6BH,CAAwB,EAC9EI,EAAmC,MAAM,KAAKF,CAAsB,EAAE,KAAK,CAAC5C,EAAKC,IAAQ1B,GAAS0B,CAAG,EAAI1B,GAASyB,CAAG,CAAC,EACtH,CAAC,eAAA6B,CAAc,EAAIT,KAKzB,SAAS2B,GAAO,CACZ,MAAMC,EAAgBL,IACtB,GAAI,CAACK,GAAiB,CAACF,EACnB,MAAO,GAEX,MAAMG,EAA8BH,EAAiC,OACjER,GAAME,GAAkBQ,EAAeV,EAAG,sBAAqB,CAAE,GAAKA,IAAO,SAAS,gBAClG,EACQ,QAASpD,EAAI,EAAGA,EAAI+D,EAA4B,OAAQ/D,IAEpD,GADiB2C,EAAemB,EAAeC,EAA4B/D,CAAC,CAAC,EAEzE,MAAO,GAGf,MAAO,EACV,CACD,MAAO,CACH,oBAAqB0D,EAAuB,KAAO,EAAIG,EAAO,IAAM,EAC5E,CACA,CAGA,SAASG,GAAsBC,EAAS,CACpC,GAAI,CAACA,EACD,MAAO,GAEX,MAAMC,EAAuB,CAAA,EAC7B,IAAIC,EAASF,EACb,KAAOE,GAAQ,CACX,KAAM,CAAC,SAAAC,CAAQ,EAAI,OAAO,iBAAiBD,CAAM,EAC7CC,EAAS,MAAM,GAAG,EAAE,KAAKC,GAAKA,EAAE,SAAS,MAAM,GAAKA,EAAE,SAAS,QAAQ,CAAC,GACxEH,EAAqB,KAAKC,CAAM,EAEpCA,EAASA,EAAO,aACnB,CACD,OAAOD,CACX,CACA,SAASP,GAA6BrD,EAAW,CAC7C,MAAMgE,EAAsB,IAAI,IAChC,QAAS/C,KAAMjB,EACX0D,GAAsBzC,CAAE,EAAE,QAAQgD,GAAaD,EAAoB,IAAIC,CAAS,CAAC,EAGrF,OACI,SAAS,iBAAiB,aAAe,SAAS,iBAAiB,cACnE,SAAS,iBAAiB,YAAc,SAAS,iBAAiB,eAElED,EAAoB,IAAI,SAAS,gBAAgB,EAE9CA,CACX,CChEO,SAASE,GAAgBpB,EAAI,CAChC,MAAMqB,EAASrB,EAAG,UAAU,EAAI,EAE1BsB,EAAS,CAAA,EACTC,EAAavB,EAAG,UAAY,SAC5BwB,EAAUD,EAAa,CAACvB,CAAE,EAAI,CAAC,GAAGA,EAAG,iBAAiB,QAAQ,CAAC,EACrE,UAAWyB,KAAUD,EACjBF,EAAO,KAAKG,EAAO,KAAK,EAG5B,GAAID,EAAQ,OAAS,EAAG,CACpB,MAAME,EAAgBH,EAAa,CAACF,CAAM,EAAI,CAAC,GAAGA,EAAO,iBAAiB,QAAQ,CAAC,EACnF,QAASzE,EAAI,EAAGA,EAAI8E,EAAc,OAAQ9E,IAAK,CAC3C,MAAM6E,EAASC,EAAc9E,CAAC,EACxB+E,EAAQL,EAAO1E,CAAC,EAChBgF,EAAWH,EAAO,cAAc,iBAAiBE,CAAK,GAAG,EAC3DC,GACAA,EAAS,aAAa,WAAY,EAAI,CAE7C,CACJ,CAED,MAAMC,EAAa7B,EAAG,UAAY,SAC5B8B,EAAWD,EAAa,CAAC7B,CAAE,EAAI,CAAC,GAAGA,EAAG,iBAAiB,QAAQ,CAAC,EACtE,GAAI8B,EAAS,OAAS,EAAG,CACrB,MAAMC,EAAiBF,EAAa,CAACR,CAAM,EAAI,CAAC,GAAGA,EAAO,iBAAiB,QAAQ,CAAC,EACpF,QAASzE,EAAI,EAAGA,EAAImF,EAAe,OAAQnF,IAAK,CAC5C,MAAMoF,EAASF,EAASlF,CAAC,EACnBqF,EAAeF,EAAenF,CAAC,EACrCqF,EAAa,MAAQD,EAAO,MAC5BC,EAAa,OAASD,EAAO,OAC7BC,EAAa,WAAW,IAAI,EAAE,UAAUD,EAAQ,EAAG,CAAC,CACvD,CACJ,CAED,OAAOX,CACX,CCxCA,MAAMa,GAA8B,GAOpC,SAASC,EAAIC,EAAU,CACnB,MAAO,GAAGA,CAAQ,IAAIF,EAA2B,QACrD,CAOO,SAASG,GAAyBC,EAAiBC,EAAoB,CAC1E,MAAMtC,EAAOqC,EAAgB,wBACvBrF,EAAYmE,GAAgBkB,CAAe,EACjDE,GAAiBF,EAAiBrF,CAAS,EAC3CA,EAAU,GAAKwF,GACfxF,EAAU,MAAM,SAAW,QAC3B,IAAIyF,EAAUzC,EAAK,IACf0C,EAAW1C,EAAK,KAGpB,GAFAhD,EAAU,MAAM,IAAM,GAAGyF,CAAO,KAChCzF,EAAU,MAAM,KAAO,GAAG0F,CAAQ,KAC9BJ,EAAoB,CACpB,MAAMK,EAASC,GAAW5C,CAAI,EAC9ByC,GAAWE,EAAO,EAAIL,EAAmB,EACzCI,GAAYC,EAAO,EAAIL,EAAmB,EAC1C,OAAO,WAAW,IAAM,CACpBtF,EAAU,MAAM,IAAM,GAAGyF,CAAO,KAChCzF,EAAU,MAAM,KAAO,GAAG0F,CAAQ,IACrC,EAAE,CAAC,CACP,CACD,OAAA1F,EAAU,MAAM,OAAS,IAEzBA,EAAU,MAAM,UAAY,aAC5BA,EAAU,MAAM,OAAS,GAAGgD,EAAK,MAAM,KACvChD,EAAU,MAAM,MAAQ,GAAGgD,EAAK,KAAK,KACrChD,EAAU,MAAM,WAAa,GAAGkF,EAAI,KAAK,CAAC,KAAKA,EAAI,MAAM,CAAC,KAAKA,EAAI,kBAAkB,CAAC,KAAKA,EAAI,SAAS,CAAC,KAAKA,EAAI,OAAO,CAAC,IAE1H,OAAO,WAAW,IAAOlF,EAAU,MAAM,YAAc,KAAKkF,EAAI,OAAO,CAAC,KAAKA,EAAI,QAAQ,CAAC,GAAK,CAAC,EAChGlF,EAAU,MAAM,OAAS,OACzBA,EAAU,MAAM,OAAS,WAElBA,CACX,CAMO,SAAS6F,GAAoC7F,EAAW,CAC3DA,EAAU,MAAM,OAAS,MAC7B,CASO,SAAS8F,GAA4B9F,EAAW+F,EAAYC,EAAeC,EAAe,CAC7FV,GAAiBQ,EAAY/F,CAAS,EACtC,MAAMkG,EAAUH,EAAW,wBACrBI,EAAgBnG,EAAU,wBAC1BoG,EAAcF,EAAQ,MAAQC,EAAc,MAC5CE,EAAeH,EAAQ,OAASC,EAAc,OACpD,GAAIC,GAAeC,EAAc,CAC7B,MAAMC,EAAiD,CACnD,MAAON,EAAgBG,EAAc,MAAQA,EAAc,MAC3D,KAAMF,EAAgBE,EAAc,KAAOA,EAAc,MACrE,EACaI,GAAeC,GAAmB,2CAA2C,IAC9ExG,EAAU,MAAM,OAAS,GAAGkG,EAAQ,MAAM,KAC1ClG,EAAU,MAAM,MAAQ,GAAGkG,EAAQ,KAAK,MAE5ClG,EAAU,MAAM,KAAO,GAAG,WAAWA,EAAU,MAAM,IAAI,EAAIsG,EAA+C,KAAOF,CAAW,KAC9HpG,EAAU,MAAM,IAAM,GAAG,WAAWA,EAAU,MAAM,GAAG,EAAIsG,EAA+C,IAAMD,CAAY,IAC/H,CACL,CAMA,SAASd,GAAiBQ,EAAYU,EAAU,CAC5C,MAAMC,EAAgB,OAAO,iBAAiBX,CAAU,EACxD,MAAM,KAAKW,CAAa,EACnB,OACGC,GACIA,EAAE,WAAW,YAAY,GACzBA,EAAE,WAAW,SAAS,GACtBA,EAAE,WAAW,MAAM,GACnBA,EAAE,WAAW,MAAM,GACnBA,EAAE,WAAW,OAAO,GACpBA,EAAE,WAAW,SAAS,GACtBA,EAAE,WAAW,SAAS,GACtBA,EAAE,WAAW,MAAM,GACnBA,EAAE,WAAW,QAAQ,GACrBA,IAAM,WACNA,IAAM,SACNA,IAAM,mBAELJ,GAAeC,GAAmB,2CAA2C,IAAMG,IAAM,SAAWA,IAAM,SAClH,EACA,QAAQA,GAAKF,EAAS,MAAM,YAAYE,EAAGD,EAAc,iBAAiBC,CAAC,EAAGD,EAAc,oBAAoBC,CAAC,CAAC,CAAC,CAC5H,CAOO,SAASC,GAAeC,EAAaC,EAAc,CACtDD,EAAY,UAAY,GACxBA,EAAY,YAAc,IAAM,GAC3BC,GAKDD,EAAY,MAAM,WAAa,GAC/BA,EAAY,MAAM,iBAAmB,GACrCA,EAAY,MAAM,OAAS,KAN3BA,EAAY,MAAM,WAAa,OAC/BA,EAAY,MAAM,iBAAmB,OACrCA,EAAY,MAAM,OAAS,OAMnC,CAMO,SAASE,GAAYC,EAAY,CACpCA,EAAW,MAAM,QAAU,OAC3BA,EAAW,MAAM,SAAW,QAC5BA,EAAW,MAAM,OAAS,IAC9B,CAMO,SAASC,GAAiBC,EAAU,CACvCA,EAAS,MAAM,WAAa,SAC5BA,EAAS,aAAaC,GAA+B,MAAM,CAC/D,CAMO,SAASC,GAAwBF,EAAU,CAC9CA,EAAS,MAAM,WAAa,GAC5BA,EAAS,gBAAgBC,EAA6B,CAC1D,CAQO,SAASE,GAAqBpH,EAAWqH,EAAY,IAAM,CAAA,EAAIC,EAAa,IAAM,GAAI,CACzFtH,EAAU,QAAQiB,GAAM,CACpB,MAAMsG,EAASF,EAAUpG,CAAE,EAC3B,OAAO,KAAKsG,CAAM,EAAE,QAAQC,GAAS,CACjCvG,EAAG,MAAMuG,CAAK,EAAID,EAAOC,CAAK,CAC1C,CAAS,EACDF,EAAWrG,CAAE,EAAE,QAAQwG,GAAKxG,EAAG,UAAU,IAAIwG,CAAC,CAAC,CACvD,CAAK,CACL,CAQO,SAASC,GAAuB1H,EAAWqH,EAAY,IAAM,CAAA,EAAIC,EAAa,IAAM,GAAI,CAC3FtH,EAAU,QAAQiB,GAAM,CACpB,MAAMsG,EAASF,EAAUpG,CAAE,EAC3B,OAAO,KAAKsG,CAAM,EAAE,QAAQC,GAAS,CACjCvG,EAAG,MAAMuG,CAAK,EAAI,EAC9B,CAAS,EACDF,EAAWrG,CAAE,EAAE,QAAQwG,GAAKxG,EAAG,UAAU,SAASwG,CAAC,GAAKxG,EAAG,UAAU,OAAOwG,CAAC,CAAC,CACtF,CAAK,CACL,CAOO,SAASE,GAAiB7E,EAAI,CACjC,MAAM8E,EAAoB9E,EAAG,MAAM,UACnCA,EAAG,MAAM,UAAY,OAAO,iBAAiBA,CAAE,EAAE,iBAAiB,QAAQ,EAC1E,MAAM+E,EAAmB/E,EAAG,MAAM,SAClC,OAAAA,EAAG,MAAM,SAAW,OAAO,iBAAiBA,CAAE,EAAE,iBAAiB,OAAO,EACjE,UAAgB,CACnBA,EAAG,MAAM,UAAY8E,EACrB9E,EAAG,MAAM,SAAW+E,CAC5B,CACA,CC7KA,MAAMC,GAAyB,UACzBC,GAA8B,IAC9BC,GAAmC,GACnCC,GAAoC,EACpCC,GAA4B,CAC9B,QAAS,oCACb,EACMC,GAAyC,oCAE/C,IAAIC,EACArI,EACAsI,EACAC,GACAC,EACAC,GACAC,EACAC,EACAC,EACAC,EACAC,EAA0B,GAC1BC,GAAyB,GACzBC,GACAC,EAA0B,GAC1BC,GAA+B,CAAA,EAGnC,MAAMC,EAAkB,IAAI,IAEtBC,EAAa,IAAI,IAEjBC,GAAwB,IAAI,QAGlC,SAASC,GAAiBC,EAAYC,EAAM,CAEnCL,EAAgB,IAAIK,CAAI,GACzBL,EAAgB,IAAIK,EAAM,IAAI,GAAK,EAElCL,EAAgB,IAAIK,CAAI,EAAE,IAAID,CAAU,IACzCJ,EAAgB,IAAIK,CAAI,EAAE,IAAID,CAAU,EACxCE,KAER,CACA,SAASC,GAAmBH,EAAYC,EAAM,CAC1CL,EAAgB,IAAIK,CAAI,EAAE,OAAOD,CAAU,EAC3CI,KACIR,EAAgB,IAAIK,CAAI,EAAE,OAAS,GACnCL,EAAgB,OAAOK,CAAI,CAEnC,CAGA,SAASI,IAAsB,CAE3B,MAAM3J,EAAYkJ,EAAgB,IAAIZ,EAAa,EAEnD,UAAWrH,KAAMjB,EACbiB,EAAG,iBAAiB2I,GAA4BC,EAAoB,EACpE5I,EAAG,iBAAiB6I,GAAyBC,EAAiB,EAC9D9I,EAAG,iBAAiB+I,GAA+BC,EAAwB,EAE/E,OAAO,iBAAiBC,GAAkCC,CAAU,EAGpE,MAAMC,EAAgB,KAAK,IAAI,GAAG,MAAM,KAAKpK,EAAU,KAAI,CAAE,EAAE,IAAIiB,GAAMkI,EAAW,IAAIlI,CAAE,EAAE,uBAAuB,CAAC,EAC9GoJ,EAAwBD,IAAkB,EAAIpC,GAAmC,KAAK,IAAIoC,EAAerC,EAA2B,EACpI7H,EAAgB+C,GAAoBjD,EAAW,IAAM4I,CAAoB,EAC/E9I,GAAQC,EAAWC,EAAWqK,EAAwB,KAAMnK,CAAa,CAC7E,CACA,SAASoK,IAAwB,CAE7B,MAAMtK,EAAYkJ,EAAgB,IAAIZ,EAAa,EACnD,UAAWrH,KAAMjB,EACbiB,EAAG,oBAAoB2I,GAA4BC,EAAoB,EACvE5I,EAAG,oBAAoB6I,GAAyBC,EAAiB,EACjE9I,EAAG,oBAAoB+I,GAA+BC,EAAwB,EAElF,OAAO,oBAAoBC,GAAkCC,CAAU,EACvEzI,IACJ,CAEA,SAAS6I,GAAqBC,EAAO,CACjC,OAAOA,EAAM,UAAUC,GAAQ,CAAC,CAACA,EAAKC,EAAgC,CAAC,CAC3E,CACA,SAASC,GAAmBtC,EAAe,CACvC,MAAO,CAAC,GAAGA,EAAe,CAACqC,EAAgC,EAAG,GAAM,CAACE,CAAW,EAAGC,EAA0B,CACjH,CAGA,SAAShB,GAAqB,EAAG,CAE7B,GAAI,CAAC,MAAAW,EAAO,uBAAAM,CAAsB,EAAI3B,EAAW,IAAI,EAAE,aAAa,EACpE,GAAI2B,GAA0B,EAAE,gBAAkBvC,EAE9C,OAOJ,GALAS,EAA0B,GAE1BwB,EAAQA,EAAM,OAAOC,GAAQA,EAAKG,CAAW,IAAMnC,EAAamC,CAAW,CAAC,EAGxErC,IAAmB,EAAE,cAAe,CAEpC,MAAMwC,EADkB5B,EAAW,IAAIZ,CAAc,EAAE,MACZ,OAAOkC,GAAQ,CAACA,EAAKC,EAAgC,CAAC,EACjGM,EAAsBzC,EAAgBwC,EAAoB,CACtD,QAASE,EAAS,wBAClB,GAAI5C,EAAcuC,CAAW,EAC7B,OAAQM,EAAQ,OAC5B,CAAS,CACJ,CACD,KAAM,CAAC,MAAA7J,EAAO,iBAAA8J,CAAgB,EAAI,EAAE,OAAO,SACrCC,EAAcD,GAAoB9J,IAAU,EAAE,cAAc,SAAS,OAAS,EAAIA,EAAQ,EAAIA,EACpGqH,EAAmB,EAAE,cACrB8B,EAAM,OAAOY,EAAa,EAAG3C,CAAY,EACzCuC,EAAsB,EAAE,cAAeR,EAAO,CAAC,QAASS,EAAS,gBAAiB,GAAI5C,EAAcuC,CAAW,EAAG,OAAQM,EAAQ,OAAO,CAAC,CAC9I,CAEA,SAASnB,GAAkB,EAAG,CAE1B,GAAI,CAAClB,EAAyB,OAE9B,KAAM,CAAC,MAAOwC,EAAe,uBAAAP,CAAsB,EAAI3B,EAAW,IAAI,EAAE,aAAa,EACrF,GAAI2B,GAA0B,EAAE,gBAAkBvC,GAAkB,EAAE,gBAAkBG,EAEpF,OAEJ,MAAM8B,EAAQ,CAAC,GAAGa,CAAa,EACzBD,EAAcb,GAAqBC,CAAK,EAC1CY,IAAgB,IAChBZ,EAAM,OAAOY,EAAa,CAAC,EAE/B,MAAME,EAAe5C,EACrBA,EAAmB,OACnB,KAAM,CAAC,KAAAa,EAAM,WAAAgC,CAAU,EAAI,EAAE,OAC7B,GACIhC,IAASiC,GAAmB,gBAC3BjC,IAASiC,GAAmB,kBAAoBD,IAAehD,GAAkBY,EAAW,IAAIoC,CAAU,EAAE,uBAC/G,CAEEvC,EAA0B,GAC1BN,EAAmBH,EAEnB,MAAMkD,EAAkBH,IAAiB/C,EAAiBiC,EAAQ,CAAC,GAAGrB,EAAW,IAAIZ,CAAc,EAAE,KAAK,EAC1GkD,EAAgB,OAAOjD,GAAa,EAAGC,CAAY,EACnDuC,EAAsBzC,EAAgBkD,EAAiB,CACnD,QAASR,EAAS,iBAClB,GAAI5C,EAAcuC,CAAW,EAC7B,OAAQM,EAAQ,OAC5B,CAAS,CACJ,CAEDF,EAAsB,EAAE,cAAeR,EAAO,CAC1C,QAASS,EAAS,aAClB,GAAI5C,EAAcuC,CAAW,EAC7B,OAAQM,EAAQ,OACxB,CAAK,CACL,CACA,SAASjB,GAAyB,EAAG,CAEjC,KAAM,CAAC,MAAOoB,EAAe,uBAAAP,CAAsB,EAAI3B,EAAW,IAAI,EAAE,aAAa,EACrF,GAAI2B,GAA0B,EAAE,gBAAkBvC,EAE9C,OAEJ,MAAMiC,EAAQ,CAAC,GAAGa,CAAa,EAC/BrC,EAA0B,GAC1B,KAAM,CAAC,MAAA3H,CAAK,EAAI,EAAE,OAAO,SACnB+J,EAAcb,GAAqBC,CAAK,EAC1CY,IAAgB,IAChBZ,EAAM,OAAOY,EAAa,CAAC,EAE/BZ,EAAM,OAAOnJ,EAAO,EAAGoH,CAAY,EACnCuC,EAAsB,EAAE,cAAeR,EAAO,CAAC,QAASS,EAAS,mBAAoB,GAAI5C,EAAcuC,CAAW,EAAG,OAAQM,EAAQ,OAAO,CAAC,CACjJ,CAGA,SAASQ,GAAgB,EAAG,CACxB,EAAE,eAAc,EAChB,MAAMjE,EAAI,EAAE,QAAU,EAAE,QAAQ,CAAC,EAAI,EACrCmB,EAAuB,CAAC,EAAGnB,EAAE,QAAS,EAAGA,EAAE,OAAO,EAClD1H,EAAU,MAAM,UAAY,eAAe6I,EAAqB,EAAID,EAAuB,CAAC,OACxFC,EAAqB,EAAID,EAAuB,CACnD,QACL,CAEA,SAASwB,GAAa,CAElBrB,GAAyB,GAEzB,OAAO,oBAAoB,YAAa4C,EAAe,EACvD,OAAO,oBAAoB,YAAaA,EAAe,EACvD,OAAO,oBAAoB,UAAWvB,CAAU,EAChD,OAAO,oBAAoB,WAAYA,CAAU,EACjDG,KACA1E,GAAoC7F,CAAS,EAExC2I,IAEDA,EAAmBH,GAGvB,GAAI,CAAC,MAAAiC,EAAO,KAAAjB,CAAI,EAAIJ,EAAW,IAAIT,CAAgB,EACnDhB,GACIwB,EAAgB,IAAIK,CAAI,EACxBtI,GAAMkI,EAAW,IAAIlI,CAAE,EAAE,gBACzBA,GAAMkI,EAAW,IAAIlI,CAAE,EAAE,iBACjC,EACI,IAAImK,EAAcb,GAAqBC,CAAK,EAExCY,IAAgB,IACZ1C,IAAqBH,IACrB6C,EAAc5C,IAItBgC,EAAQA,EAAM,IAAIC,GAASA,EAAKC,EAAgC,EAAIrC,EAAgBoC,CAAK,EACzF,SAASkB,GAAqB,CAC1B5C,KACA6C,EAAsBlD,EAAkB8B,EAAO,CAC3C,QAASxB,EAA0BiC,EAAS,uBAAyBA,EAAS,kBAC9E,GAAI5C,EAAcuC,CAAW,EAC7B,OAAQM,EAAQ,OAC5B,CAAS,EACGxC,IAAqBH,GAErBqD,EAAsBrD,EAAgBY,EAAW,IAAIZ,CAAc,EAAE,MAAO,CACxE,QAAS0C,EAAS,qBAClB,GAAI5C,EAAcuC,CAAW,EAC7B,OAAQM,EAAQ,OAChC,CAAa,EAEDE,IAAgB,IAAIjE,GAAwBuB,EAAiB,SAAS0C,CAAW,CAAC,EACtFS,IACH,CACDC,GAA8BV,EAAaO,CAAkB,CACjE,CAGA,SAASG,GAA8BV,EAAaW,EAAU,CAC1D,MAAMC,EACFZ,EAAc,GAAKa,GAA4BvD,EAAiB,SAAS0C,CAAW,CAAC,EAAIa,GAA4BvD,CAAgB,EACnIwD,EAAe,CACjB,EAAGF,EAAa,KAAO,WAAWjM,EAAU,MAAM,IAAI,EACtD,EAAGiM,EAAa,IAAM,WAAWjM,EAAU,MAAM,GAAG,CAC5D,EACU,CAAC,wBAAAoM,CAAuB,EAAIhD,EAAW,IAAIT,CAAgB,EAC3D0D,EAAa,aAAaD,CAAuB,UACvDpM,EAAU,MAAM,WAAaA,EAAU,MAAM,WAAaA,EAAU,MAAM,WAAa,IAAMqM,EAAaA,EAC1GrM,EAAU,MAAM,UAAY,eAAemM,EAAa,CAAC,OAAOA,EAAa,CAAC,SAC9E,OAAO,WAAWH,EAAUI,CAAuB,CACvD,CAEA,SAASE,GAA8BpL,EAAIqL,EAAS,CAChDrD,GAA6B,KAAK,CAAC,GAAAhI,EAAI,QAAAqL,CAAO,CAAC,EAC/C,OAAO,sBAAsB,IAAM,CAC/BxF,GAAY7F,CAAE,EACd,SAAS,KAAK,YAAYA,CAAE,CACpC,CAAK,CACL,CAEA,SAAS4K,IAAkB,CACvB9L,EAAU,OAAM,EAChBqI,EAAmB,OAAM,EACrBa,GAA6B,SAE7BA,GAA6B,QAAQ,CAAC,CAAC,GAAAhI,EAAI,QAAAqL,CAAO,IAAM,CACpDA,IACArL,EAAG,OAAM,CACrB,CAAS,EACDgI,GAA+B,CAAA,GAEnClJ,EAAY,OACZqI,EAAqB,OACrBC,EAAgB,OAChBC,GAAgB,OAChBC,EAAiB,OACjBC,GAAc,OACdC,EAAe,OACfC,EAAmB,OACnBC,EAAyB,OACzBC,EAAuB,OACvBC,EAA0B,GAC1BC,GAAyB,GACzBC,GAA8B,OAC9BC,EAA0B,EAC9B,CAEO,SAASuD,GAAQvN,EAAMwN,EAAS,CACnC,IAAIC,EAAc,GAClB,MAAMC,EAAS,CACX,MAAO,OACP,KAAM,OACN,eAAgB,EAChB,aAAc,GACd,cAAe,GACf,uBAAwB,GACxB,gBAAiBxE,GACjB,kBAAmB,CAAE,EACrB,wBAAyB,IAAM,CAAE,EACjC,sBAAuB,EAC/B,EAEI,IAAIyE,EAAU,IAAI,IAElB,SAASC,GAAoB,CACzB,OAAO,iBAAiB,YAAaC,EAA+B,CAAC,QAAS,EAAK,CAAC,EACpF,OAAO,iBAAiB,YAAaA,EAA+B,CAAC,QAAS,GAAO,QAAS,EAAK,CAAC,EACpG,OAAO,iBAAiB,UAAWC,EAAkB,CAAC,QAAS,EAAK,CAAC,EACrE,OAAO,iBAAiB,WAAYA,EAAkB,CAAC,QAAS,EAAK,CAAC,CACzE,CACD,SAASC,GAAuB,CAC5B,OAAO,oBAAoB,YAAaF,CAA6B,EACrE,OAAO,oBAAoB,YAAaA,CAA6B,EACrE,OAAO,oBAAoB,UAAWC,CAAgB,EACtD,OAAO,oBAAoB,WAAYA,CAAgB,CAC1D,CACD,SAASA,GAAmB,CACxBC,IACA3E,EAAqB,OACrBO,EAAyB,OACzBC,EAAuB,MAC1B,CAED,SAASiE,EAA8BG,EAAG,CACtCA,EAAE,eAAc,EAChB,MAAMvF,EAAIuF,EAAE,QAAUA,EAAE,QAAQ,CAAC,EAAIA,EACrCpE,EAAuB,CAAC,EAAGnB,EAAE,QAAS,EAAGA,EAAE,OAAO,GAE9C,KAAK,IAAImB,EAAqB,EAAID,EAAuB,CAAC,GAAKV,IAC/D,KAAK,IAAIW,EAAqB,EAAID,EAAuB,CAAC,GAAKV,MAE/D8E,IACAE,IAEP,CACD,SAASC,EAAgBF,EAAG,CAWxB,GATIA,EAAE,SAAWA,EAAE,gBAAkBA,EAAE,OAAO,QAAU,QAAaA,EAAE,OAAO,oBAK1EA,EAAE,QAIFnE,EAEA,OAEJmE,EAAE,gBAAe,EACjB,MAAMvF,EAAIuF,EAAE,QAAUA,EAAE,QAAQ,CAAC,EAAIA,EACrCrE,EAAyB,CAAC,EAAGlB,EAAE,QAAS,EAAGA,EAAE,OAAO,EACpDmB,EAAuB,CAAC,GAAGD,CAAsB,EACjDP,EAAqB4E,EAAE,cACvBJ,GACH,CAED,SAASK,GAAkB,CAEvBpE,EAA0B,GAG1B,MAAMsE,EAAaR,EAAQ,IAAIvE,CAAkB,EACjDI,GAAc2E,EACd5E,EAAiBH,EAAmB,cAEpC,MAAMgF,EAAW7E,EAAe,QAAQ,QAAQ,GAAKA,EAAe,cAC9D8E,EAAqBD,EAAS,MAAQA,EACtC,CAAC,MAAO/B,EAAe,KAAA9B,EAAM,sBAAA+D,CAAqB,EAAIZ,EACtDlC,EAAQ,CAAC,GAAGa,CAAa,EAC/BhD,EAAgBmC,EAAM2C,CAAU,EAChC7E,GAAgBiB,EAChBd,EAAekC,GAAmBtC,CAAa,EAG/CtI,EAAYoF,GAAyBiD,EAAoBkF,GAAyB1E,CAAoB,EACtGR,EAAmB,aAAaD,GAAwC,EAAI,EAG5E,SAASoF,GAA2B,CAC3BxN,EAAU,cAUX,OAAO,sBAAsBwN,CAAwB,GATrDF,EAAmB,YAAYtN,CAAS,EAExCA,EAAU,MAAK,EACf4J,KACA7C,GAAYsB,CAAkB,EAC9BiF,EAAmB,YAAYjF,CAAkB,EAEjDK,EAAamC,CAAW,EAAIvC,EAAcuC,CAAW,EAI5D,CACD,OAAO,sBAAsB2C,CAAwB,EAErDnG,GACI,MAAM,KAAK8B,EAAgB,IAAIwD,EAAO,IAAI,CAAC,EAAE,OAAOzL,GAAMA,IAAOsH,GAAkB,CAACY,EAAW,IAAIlI,CAAE,EAAE,sBAAsB,EAC7HA,GAAMkI,EAAW,IAAIlI,CAAE,EAAE,gBACzBA,GAAMkI,EAAW,IAAIlI,CAAE,EAAE,iBACrC,EAGQuJ,EAAM,OAAO2C,EAAY,EAAG1E,CAAY,EACxCM,GAA8BpB,GAAiBY,CAAc,EAE7DyC,EAAsBzC,EAAgBiC,EAAO,CAAC,QAASS,EAAS,aAAc,GAAI5C,EAAcuC,CAAW,EAAG,OAAQM,EAAQ,OAAO,CAAC,EAGtI,OAAO,iBAAiB,YAAaQ,GAAiB,CAAC,QAAS,EAAK,CAAC,EACtE,OAAO,iBAAiB,YAAaA,GAAiB,CAAC,QAAS,GAAO,QAAS,EAAK,CAAC,EACtF,OAAO,iBAAiB,UAAWvB,EAAY,CAAC,QAAS,EAAK,CAAC,EAC/D,OAAO,iBAAiB,WAAYA,EAAY,CAAC,QAAS,EAAK,CAAC,CACnE,CAED,SAASqD,EAAU,CACf,MAAAhD,EAAQ,OACR,eAAgB2B,EAA0B,EAC1C,KAAMsB,EAAU3F,GAChB,aAAAjB,EAAe,GACf,cAAA6G,EAAgB,GAChB,uBAAA5C,EAAyB,GACzB,gBAAA6C,EAAkBzF,GAClB,kBAAA0F,EAAoB,CAAE,EACtB,wBAAAC,EAA0B,IAAM,CAAE,EAClC,sBAAAP,GAAwB,EAChC,EAAO,CACCZ,EAAO,wBAA0BP,EAC7BO,EAAO,MAAQe,IAAYf,EAAO,MAClCjD,GAAmBzK,EAAM0N,EAAO,IAAI,EAExCA,EAAO,KAAOe,EACdf,EAAO,MAAQ,CAAC,GAAGlC,CAAK,EACxBkC,EAAO,aAAe7F,EACtB6F,EAAO,cAAgBgB,EACvBhB,EAAO,wBAA0BmB,EACjCnB,EAAO,sBAAwBY,GAI3Bb,GACA5D,GACA,CAACC,KACA,CAAC3J,GAAuBwO,EAAiBjB,EAAO,eAAe,GAC5D,CAACnN,GAA+BqO,EAAmBlB,EAAO,iBAAiB,KAE/EhF,GACI,CAAC1I,CAAI,EACL,IAAM0N,EAAO,gBACb,IAAMkB,CACtB,EACYxG,GACI,CAACpI,CAAI,EACL,IAAM2O,EACN,IAAMC,CACtB,GAEQlB,EAAO,gBAAkBiB,EACzBjB,EAAO,kBAAoB,CAAC,GAAGkB,CAAiB,EAGhD,SAASE,GAAc7M,EAAI8M,EAAU,CACjC,OAAO5E,EAAW,IAAIlI,CAAE,EAAIkI,EAAW,IAAIlI,CAAE,EAAE8M,CAAQ,EAAIrB,EAAOqB,CAAQ,CAC7E,CACGtB,GAAe5D,GAA2B6D,EAAO,yBAA2B5B,IACxEA,EACApD,GACI,CAAC1I,CAAI,EACLiC,GAAM6M,GAAc7M,EAAI,iBAAiB,EACzCA,GAAM6M,GAAc7M,EAAI,mBAAmB,CAC/D,EAEgBmG,GACI,CAACpI,CAAI,EACLiC,GAAM6M,GAAc7M,EAAI,iBAAiB,EACzCA,GAAM6M,GAAc7M,EAAI,mBAAmB,CAC/D,GAGQyL,EAAO,uBAAyB5B,EAEhC3B,EAAW,IAAInK,EAAM0N,CAAM,EAC3BrD,GAAiBrK,EAAMyO,CAAO,EAC9B,MAAMrC,GAAcb,GAAqBmC,EAAO,KAAK,EACrD,QAASsB,EAAM,EAAGA,EAAMhP,EAAK,SAAS,OAAQgP,IAAO,CACjD,MAAMpH,EAAc5H,EAAK,SAASgP,CAAG,EAErC,GADArH,GAAeC,EAAaC,CAAY,EACpCmH,IAAQ5C,GAAa,CACrBsB,EAAO,wBAAwB3M,EAAWsI,EAAe2F,CAAG,EACvDN,GACD7H,GAA4B9F,EAAW6G,EAAagC,EAAqB,EAAGA,EAAqB,CAAC,EAEtG5B,GAAiBJ,CAAW,EAC5B,QACH,CACDA,EAAY,oBAAoB,YAAawC,GAAsB,IAAIxC,CAAW,CAAC,EACnFA,EAAY,oBAAoB,aAAcwC,GAAsB,IAAIxC,CAAW,CAAC,EAC/EC,IACDD,EAAY,iBAAiB,YAAasG,CAAe,EACzDtG,EAAY,iBAAiB,aAAcsG,CAAe,EAC1D9D,GAAsB,IAAIxC,EAAasG,CAAe,GAG1DP,EAAQ,IAAI/F,EAAaoH,CAAG,EAEvBvB,IACDA,EAAc,GAErB,CACJ,CACD,OAAAe,EAAUhB,CAAO,EAEV,CACH,OAAQyB,GAAc,CAElBT,EAAUS,CAAU,CACvB,EACD,QAAS,IAAM,CACX,SAASC,GAAY,CAEjBzE,GAAmBzK,EAAMmK,EAAW,IAAInK,CAAI,EAAE,IAAI,EAClDmK,EAAW,OAAOnK,CAAI,CACzB,CACG6J,GAA2B,CAAC7J,EAAK,QAAQ,IAAImJ,EAAsC,GAAG,EAEtFkE,GAA8BrN,EAAMkP,CAAS,EAE7CA,GAEP,CACT,CACA,CCrjBA,MAAMC,GAAkB,CACpB,gBAAiB,kBACjB,uBAAwB,wBAC5B,EACMC,GAAoB,CACtB,CAACD,GAAgB,eAAe,EAAG,yEACnC,CAACA,GAAgB,sBAAsB,EAAG,uCAC9C,EAEME,GAAe,wBACrB,IAAIC,EAEJ,SAASC,IAAoB,CACrBD,IAKJA,EAAY,SAAS,cAAc,KAAK,EACvC,UAAyB,CACtBA,EAAU,GAAKD,GAGfC,EAAU,MAAM,SAAW,QAC3BA,EAAU,MAAM,OAAS,IACzBA,EAAU,MAAM,KAAO,IACvBA,EAAU,MAAM,OAAS,KACzBA,EAAU,MAAM,QAAU,IAC1BA,EAAU,MAAM,OAAS,IACzBA,EAAU,MAAM,MAAQ,IACxBA,EAAU,aAAa,OAAQ,OAAO,CAC9C,IACI,SAAS,KAAK,QAAQA,CAAS,EAG/B,OAAO,QAAQF,EAAiB,EAAE,QAAQ,CAAC,CAACI,EAAIC,CAAG,IAAM,SAAS,KAAK,QAAQC,GAAuBF,EAAIC,CAAG,CAAC,CAAC,EACnH,CAMO,SAASE,IAAW,CACvB,OAAIC,GAAmB,MACnB,SAAS,aAAe,WACxBL,KAEA,OAAO,iBAAiB,mBAAoBA,EAAiB,EAE1D,CAAC,GAAGJ,EAAe,EAC9B,CAKO,SAASU,IAAc,CACtBD,IAAc,CAACN,IACnB,OAAO,KAAKF,EAAiB,EAAE,QAAQI,UAAM,OAAAM,EAAA,SAAS,eAAeN,CAAE,IAA1B,YAAAM,EAA6B,SAAQ,EAClFR,EAAU,OAAM,EAChBA,EAAY,OAChB,CAEA,SAASI,GAAuBF,EAAIC,EAAK,CACrC,MAAMM,EAAM,SAAS,cAAc,KAAK,EACxC,OAAAA,EAAI,GAAKP,EACTO,EAAI,UAAY,MAAMN,CAAG,OACzBM,EAAI,MAAM,QAAU,OACpBA,EAAI,MAAM,SAAW,QACrBA,EAAI,MAAM,OAAS,KACZA,CACX,CAMO,SAASC,EAAoBP,EAAK,CACrC,GAAIG,GAAY,OACXN,GACDC,KAEJD,EAAU,UAAY,GACtB,MAAMW,EAAY,SAAS,eAAeR,CAAG,EAC7CH,EAAU,YAAYW,CAAS,EAE/BX,EAAU,MAAM,QAAU,OAC1BA,EAAU,MAAM,QAAU,QAC9B,CClFA,MAAMxG,GAAyB,UACzBI,GAA4B,CAC9B,QAAS,oCACb,EAEA,IAAIgH,EAAa,GACbC,GACAC,EACAC,EAAiB,GACjBC,EACAC,EACAC,EAAmB,GACvB,MAAMC,GAAiB,IAAI,QACrBC,GAAuB,IAAI,QAC3BC,GAAqB,IAAI,QACzBC,GAAc,IAAI,IAClBzG,EAAa,IAAI,IACjBD,EAAkB,IAAI,IAO5B,IAAIiF,GAGJ,SAAS9E,GAAiBC,EAAYC,EAAM,CAEpCL,EAAgB,OAAS,IAEzBiF,GAAkBQ,GAAQ,EAC1B,OAAO,iBAAiB,UAAWkB,EAAoB,EACvD,OAAO,iBAAiB,QAASC,EAAkB,GAElD5G,EAAgB,IAAIK,CAAI,GACzBL,EAAgB,IAAIK,EAAM,IAAI,GAAK,EAElCL,EAAgB,IAAIK,CAAI,EAAE,IAAID,CAAU,IACzCJ,EAAgB,IAAIK,CAAI,EAAE,IAAID,CAAU,EACxCE,KAER,CACA,SAASC,GAAmBH,EAAYC,EAAM,CAEtC6F,IAAc9F,GACda,IAEJjB,EAAgB,IAAIK,CAAI,EAAE,OAAOD,CAAU,EAC3CI,KACIR,EAAgB,IAAIK,CAAI,EAAE,OAAS,GACnCL,EAAgB,OAAOK,CAAI,EAE3BL,EAAgB,OAAS,IAEzB,OAAO,oBAAoB,UAAW2G,EAAoB,EAC1D,OAAO,oBAAoB,QAASC,EAAkB,EACtD3B,GAAkB,OAClBU,KAER,CAEA,SAASgB,GAAqB,EAAG,CAC7B,GAAKX,EACL,OAAQ,EAAE,IAAG,CACT,IAAK,SAAU,CACX/E,IACA,KACH,CACJ,CACL,CAEA,SAAS2F,IAAqB,CACrBZ,IACAO,GAAe,IAAI,SAAS,aAAa,GAE1CtF,IAER,CAEA,SAAS4F,GAAgB,EAAG,CAExB,GAAI,CAACb,EAAY,OACjB,MAAMc,EAAiB,EAAE,cACzB,GAAIA,IAAmBZ,EAAW,OAElCC,EAAiBW,EAAe,aAAa,YAAY,GAAK,GAC9D,KAAM,CAAC,MAAOC,CAAW,EAAI9G,EAAW,IAAIiG,CAAS,EAC/Cc,EAAaD,EAAY,KAAKxF,GAAQA,EAAKG,CAAW,IAAM2E,CAAa,EACzEY,EAAYF,EAAY,QAAQC,CAAU,EAC1CE,EAAaH,EAAY,OAAOE,EAAW,CAAC,EAAE,CAAC,EAC/C,CAAC,MAAOE,EAAa,iBAAAC,CAAgB,EAAInH,EAAW,IAAI6G,CAAc,EAExEA,EAAe,sBAAqB,EAAG,IAAMZ,EAAU,sBAAuB,EAAC,KAC/EY,EAAe,sBAAqB,EAAG,KAAOZ,EAAU,sBAAuB,EAAC,MAEhFiB,EAAY,KAAKD,CAAU,EACtBE,GACDtB,EAAoB,cAAcQ,CAAgB,2BAA2BH,CAAc,EAAE,IAGjGgB,EAAY,QAAQD,CAAU,EACzBE,GACDtB,EAAoB,cAAcQ,CAAgB,iCAAiCH,CAAc,EAAE,GAI3GzD,EADewD,EACea,EAAa,CAAC,QAAShF,EAAS,qBAAsB,GAAIsE,EAAe,OAAQrE,EAAQ,QAAQ,CAAC,EAChIU,EAAsBoE,EAAgBK,EAAa,CAAC,QAASpF,EAAS,kBAAmB,GAAIsE,EAAe,OAAQrE,EAAQ,QAAQ,CAAC,EACrIkE,EAAYY,CAChB,CAEA,SAASO,IAAsB,CAC3BX,GAAY,QAAQ,CAAC,CAAC,OAAAY,CAAM,EAAGvP,IAAOuP,EAAOrH,EAAW,IAAIlI,CAAE,CAAC,CAAC,CACpE,CAEA,SAASkJ,EAAWsG,EAAmB,GAAM,CAEpCtH,EAAW,IAAIiG,CAAS,EAAE,kBAC3BJ,EAAoB,yBAAyBQ,CAAgB,EAAE,EAE/DC,GAAe,IAAI,SAAS,aAAa,GACzC,SAAS,cAAc,OAEvBgB,GACAzF,EAAsBoE,EAAWjG,EAAW,IAAIiG,CAAS,EAAE,MAAO,CAC9D,QAASnE,EAAS,aAClB,GAAIsE,EACJ,OAAQrE,EAAQ,QAC5B,CAAS,EAELxD,GACIwB,EAAgB,IAAIiG,EAAe,EACnClO,GAAMkI,EAAW,IAAIlI,CAAE,EAAE,gBACzBA,GAAMkI,EAAW,IAAIlI,CAAE,EAAE,iBACjC,EACIqO,EAAc,KACdC,EAAgB,KAChBC,EAAmB,GACnBL,GAAkB,KAClBC,EAAY,KACZC,EAAiB,GACjBH,EAAa,GACbqB,IACJ,CAEO,SAAShE,GAAQvN,EAAMwN,EAAS,CACnC,MAAME,EAAS,CACX,MAAO,OACP,KAAM,OACN,aAAc,GACd,aAAc,EACd,iBAAkB,EAClB,uBAAwB,GACxB,gBAAiBxE,GACjB,kBAAmB,CAAE,EACrB,iBAAkB,EAC1B,EAEI,SAASwI,EAAKC,EAAKjR,EAAGkR,EAAG,CACjBD,EAAI,QAAU,GAClBA,EAAI,OAAOC,EAAG,EAAGD,EAAI,OAAOjR,EAAG,EAAGiR,EAAIC,CAAC,CAAC,EAAE,CAAC,CAAC,CAC/C,CAED,SAASC,EAAc7D,EAAG,CAEtB,OAAQA,EAAE,IAAG,CACT,IAAK,QACL,IAAK,IAAK,CAEN,IAAKA,EAAE,OAAO,WAAa,QAAaA,EAAE,OAAO,MAAQA,EAAE,OAAO,oBAAsB,CAACyC,GAAe,IAAIzC,EAAE,MAAM,EAChH,OAEJA,EAAE,eAAc,EAChBA,EAAE,gBAAe,EACbkC,EAEA/E,IAGA8C,EAAgBD,CAAC,EAErB,KACH,CACD,IAAK,YACL,IAAK,aAAc,CACf,GAAI,CAACkC,EAAY,OACjBlC,EAAE,eAAc,EAChBA,EAAE,gBAAe,EACjB,KAAM,CAAC,MAAAxC,CAAK,EAAIrB,EAAW,IAAInK,CAAI,EAC7B8R,EAAW,MAAM,KAAK9R,EAAK,QAAQ,EACnCgP,EAAM8C,EAAS,QAAQ9D,EAAE,aAAa,EAExCgB,EAAM8C,EAAS,OAAS,IACnBpE,EAAO,kBACRsC,EAAoB,cAAcQ,CAAgB,gBAAgBxB,EAAM,CAAC,gBAAgBqB,CAAc,EAAE,EAE7GqB,EAAKlG,EAAOwD,EAAKA,EAAM,CAAC,EACxBpC,EAAsB5M,EAAMwL,EAAO,CAAC,QAASS,EAAS,kBAAmB,GAAIsE,EAAe,OAAQrE,EAAQ,QAAQ,CAAC,GAEzH,KACH,CACD,IAAK,UACL,IAAK,YAAa,CACd,GAAI,CAACgE,EAAY,OACjBlC,EAAE,eAAc,EAChBA,EAAE,gBAAe,EACjB,KAAM,CAAC,MAAAxC,CAAK,EAAIrB,EAAW,IAAInK,CAAI,EAE7BgP,EADW,MAAM,KAAKhP,EAAK,QAAQ,EACpB,QAAQgO,EAAE,aAAa,EAExCgB,EAAM,IACDtB,EAAO,kBACRsC,EAAoB,cAAcQ,CAAgB,gBAAgBxB,CAAG,gBAAgBqB,CAAc,EAAE,EAEzGqB,EAAKlG,EAAOwD,EAAKA,EAAM,CAAC,EACxBpC,EAAsB5M,EAAMwL,EAAO,CAAC,QAASS,EAAS,kBAAmB,GAAIsE,EAAe,OAAQrE,EAAQ,QAAQ,CAAC,GAEzH,KACH,CACJ,CACJ,CACD,SAAS+B,EAAgBD,EAAG,CAExB+D,EAAsB/D,EAAE,aAAa,EACrCoC,EAAYpQ,EACZmQ,GAAkBzC,EAAO,KACzBwC,EAAa,GACb,MAAM8B,EAAc,MAAM,KAAK9H,EAAgB,IAAIwD,EAAO,IAAI,CAAC,EAAE,OAAOzL,GAAMA,IAAOmO,GAAa,CAACjG,EAAW,IAAIlI,CAAE,EAAE,sBAAsB,EAM5I,GALAmG,GACI4J,EACA/P,GAAMkI,EAAW,IAAIlI,CAAE,EAAE,gBACzBA,GAAMkI,EAAW,IAAIlI,CAAE,EAAE,iBACrC,EACY,CAACyL,EAAO,iBAAkB,CAC1B,IAAIuE,EAAM,yBAAyBzB,CAAgB,mDAAmDH,CAAc,GAChH2B,EAAY,OAAS,IACrBC,GAAO,8DAEXjC,EAAoBiC,CAAG,CAC1B,CACDjG,EAAsBhM,EAAMmK,EAAW,IAAInK,CAAI,EAAE,MAAO,CAAC,QAASiM,EAAS,aAAc,GAAIsE,EAAe,OAAQrE,EAAQ,QAAQ,CAAC,EACrIqF,IACH,CAED,SAASW,EAAYlE,EAAG,CACfkC,GACDlC,EAAE,gBAAkBsC,IACxBtC,EAAE,gBAAe,EACjB7C,EAAW,EAAK,EAChB8C,EAAgBD,CAAC,EACpB,CACD,SAAS+D,EAAsBnK,EAAa,CACxC,KAAM,CAAC,MAAA4D,CAAK,EAAIrB,EAAW,IAAInK,CAAI,EAC7B8R,EAAW,MAAM,KAAK9R,EAAK,QAAQ,EACnCmS,EAAiBL,EAAS,QAAQlK,CAAW,EACnD0I,EAAc1I,EACd0I,EAAY,SAAW5C,EAAO,iBAC9B6C,EAAgB/E,EAAM2G,CAAc,EAAEvG,CAAW,EACjD4E,EAAmBsB,EAASK,CAAc,EAAE,aAAa,YAAY,GAAK,EAC7E,CAED,SAAS3D,EAAU,CACf,MAAAhD,EAAQ,CAAE,EACV,KAAMiD,EAAU3F,GAChB,aAAAjB,EAAe,GACf,aAAAuK,EAAe,EACf,iBAAAC,EAAmB,EACnB,uBAAAvG,EAAyB,GACzB,gBAAA6C,EAAkBzF,GAClB,kBAAA0F,EAAoB,CAAE,EACtB,iBAAA0C,EAAmB,EAC3B,EAAO,CACC5D,EAAO,MAAQ,CAAC,GAAGlC,CAAK,EACxBkC,EAAO,aAAe7F,EACtB6F,EAAO,uBAAyB5B,EAChC4B,EAAO,aAAe0E,EACtB1E,EAAO,iBAAmB2E,EAC1B3E,EAAO,gBAAkBiB,EACzBjB,EAAO,kBAAoBkB,EAC3BlB,EAAO,iBAAmB4D,EACtB5D,EAAO,MAAQe,IAAYf,EAAO,MAClCjD,GAAmBzK,EAAM0N,EAAO,IAAI,EAExCA,EAAO,KAAOe,EACdpE,GAAiBrK,EAAMyO,CAAO,EACzB6C,IACDtR,EAAK,aAAa,gBAAiB6H,CAAY,EAC/C7H,EAAK,aAAa,OAAQ,MAAM,EAChCA,EAAK,aAAa,mBAAoB6H,EAAesH,GAAgB,uBAAyBA,GAAgB,eAAe,GAEjIhF,EAAW,IAAInK,EAAM0N,CAAM,EAEvBwC,EACAlQ,EAAK,SACDA,IAASoQ,GACTE,EAAY,SAAStQ,CAAI,GACzB0N,EAAO,wBACN0C,GAAa1C,EAAO,OAASvD,EAAW,IAAIiG,CAAS,EAAE,KAClD,GACA,EAEVpQ,EAAK,SAAW0N,EAAO,aAG3B1N,EAAK,iBAAiB,QAAS+Q,EAAe,EAE9C,QAASrQ,EAAI,EAAGA,EAAIV,EAAK,SAAS,OAAQU,IAAK,CAC3C,MAAMkH,EAAc5H,EAAK,SAASU,CAAC,EACnC+P,GAAe,IAAI7I,CAAW,EAC9BA,EAAY,SAAWsI,EAAa,GAAKxC,EAAO,iBAC3C4D,GACD1J,EAAY,aAAa,OAAQ,UAAU,EAE/CA,EAAY,oBAAoB,UAAW8I,GAAqB,IAAI9I,CAAW,CAAC,EAChFA,EAAY,oBAAoB,QAAS+I,GAAmB,IAAI/I,CAAW,CAAC,EACvEC,IACDD,EAAY,iBAAiB,UAAWiK,CAAa,EACrDnB,GAAqB,IAAI9I,EAAaiK,CAAa,EACnDjK,EAAY,iBAAiB,QAASsK,CAAW,EACjDvB,GAAmB,IAAI/I,EAAasK,CAAW,GAE/ChC,GAAcxC,EAAO,MAAMhN,CAAC,EAAEkL,CAAW,IAAM2E,IAG/CD,EAAc1I,EACd0I,EAAY,SAAW5C,EAAO,iBAE9B9F,EAAY,MAAK,EAExB,CACJ,CACD4G,EAAUhB,CAAO,EAEjB,MAAM8E,EAAU,CACZ,OAAQrD,GAAc,CAElBT,EAAUS,CAAU,CACvB,EACD,QAAS,IAAM,CAEXxE,GAAmBzK,EAAM0N,EAAO,IAAI,EACpCvD,EAAW,OAAOnK,CAAI,EACtB4Q,GAAY,OAAO5Q,CAAI,CAC1B,CACT,EACI,OAAA4Q,GAAY,IAAI5Q,EAAMsS,CAAO,EACtBA,CACX,CCxUO,SAAS/E,GAAQvN,EAAMwN,EAAS,CACnC,GAAI+E,GAAiBvS,CAAI,EACrB,MAAO,CACH,OAAQ,IAAM,CAAE,EAChB,QAAS,IAAM,CAAE,CAC7B,EAEIwS,GAAgBhF,CAAO,EACvB,MAAMiF,EAAcC,GAAe1S,EAAMwN,CAAO,EAC1CmF,EAAeC,GAAgB5S,EAAMwN,CAAO,EAClD,MAAO,CACH,OAAQyB,GAAc,CAClBuD,GAAgBvD,CAAU,EAC1BwD,EAAY,OAAOxD,CAAU,EAC7B0D,EAAa,OAAO1D,CAAU,CACjC,EACD,QAAS,IAAM,CACXwD,EAAY,QAAO,EACnBE,EAAa,QAAO,CACvB,CACT,CACA,CAQA,SAASJ,GAAiBvS,EAAM,CAC5B,MAAO,CAAC,CAACA,EAAK,QAAQ,IAAI6S,EAAkC,UAAU,CAC1E,CAEA,SAASL,GAAgBhF,EAAS,CAE9B,KAAM,CACF,MAAAhC,EACA,eAAAsH,EACA,KAAAvI,EACA,aAAA1C,EACA,cAAA6G,EACA,uBAAA5C,EACA,aAAAsG,EACA,iBAAAC,EACA,gBAAA1D,EACA,kBAAAC,EACA,wBAAAC,EACA,iBAAAyC,EACA,sBAAAhD,EACA,GAAGyE,CACN,EAAGvF,EAKJ,GAHI,OAAO,KAAKuF,CAAI,EAAE,OAAS,GAC3B,QAAQ,KAAK,sCAAuCA,CAAI,EAExD,CAACvH,EACD,MAAM,IAAI,MAAM,oCAAoC,EAExD,MAAMwH,EAAoBxH,EAAM,KAAKC,GAAQ,CAAC,GAAG,eAAe,KAAKA,EAAMG,CAAW,CAAC,EACvF,GAAIoH,EACA,MAAM,IAAI,MAAM,YAAYpH,CAAW,uBAAuB/L,GAASmT,CAAiB,CAAC,EAAE,EAE/F,GAAIpE,GAAqB,CAAC,MAAM,QAAQA,CAAiB,EACrD,MAAM,IAAI,MAAM,4DAA4D,OAAOA,CAAiB,KAAK/O,GAAS+O,CAAiB,CAAC,EAAE,EAE1I,GAAIwD,GAAgB,CAACa,GAAMb,CAAY,EACnC,MAAM,IAAI,MAAM,uDAAuD,OAAOA,CAAY,KAAKvS,GAASuS,CAAY,CAAC,EAAE,EAE3H,GAAIC,GAAoB,CAACY,GAAMZ,CAAgB,EAC3C,MAAM,IAAI,MAAM,2DAA2D,OAAOA,CAAgB,KAAKxS,GAASwS,CAAgB,CAAC,EAAE,CAE3I,CAEA,SAASY,GAAMxN,EAAO,CAClB,MACI,CAAC,MAAMA,CAAK,GACX,SAAUyN,EAAG,CACV,OAAQA,EAAI,KAAOA,CAC/B,EAAW,WAAWzN,CAAK,CAAC,CAE5B,CCxGA,SAAS0N,GAAKnT,EAAM,CAAE,KAAAoT,EAAM,GAAAC,CAAI,EAAEC,EAAS,GAAI,CAC3C,MAAM9K,EAAQ,iBAAiBxI,CAAI,EAC7BuT,EAAY/K,EAAM,YAAc,OAAS,GAAKA,EAAM,UACpD,CAACgL,EAAIC,CAAE,EAAIjL,EAAM,gBAAgB,MAAM,GAAG,EAAE,IAAI,UAAU,EAC1DkL,EAAMN,EAAK,KAAOA,EAAK,MAAQI,EAAKH,EAAG,OAAUA,EAAG,KAAOG,GAC3DG,EAAMP,EAAK,IAAMA,EAAK,OAASK,EAAKJ,EAAG,QAAWA,EAAG,IAAMI,GAC3D,CAAE,MAAAG,EAAQ,EAAG,SAAAC,EAAYC,GAAM,KAAK,KAAKA,CAAC,EAAI,IAAK,OAAAC,EAASC,EAAQ,EAAKV,EAC/E,MAAO,CACH,MAAAM,EACA,SAAUK,GAAYJ,CAAQ,EAAIA,EAAS,KAAK,KAAKH,EAAKA,EAAKC,EAAKA,CAAE,CAAC,EAAIE,EAC3E,OAAAE,EACA,IAAK,CAACG,EAAGC,IAAM,CACX,MAAMjB,EAAIiB,EAAIT,EACRU,EAAID,EAAIR,EACRU,EAAKH,EAAIC,EAAIf,EAAK,MAAQC,EAAG,MAC7BiB,EAAKJ,EAAIC,EAAIf,EAAK,OAASC,EAAG,OACpC,MAAO,cAAcE,CAAS,cAAcL,CAAC,OAAOkB,CAAC,aAAaC,CAAE,KAAKC,CAAE,IAC9E,CACT,CACA","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}